// DO NOT EDIT THIS FILE
// This file is automatically generated by go-dsl.
// Rerun go-dsl to update the language.
// Warning: Files prefixed with `dsl_` or `template_` will be removed,
// any manual changes will be lost.

package language

import (
    "image"
    "image/color"
    "sync"
)

// NewLanguage creates a new isolated language instance
func NewLanguage() *dslCollection {
    l := &dslCollection{
        mu: &sync.Mutex{},
    }
    l.initDSL(
        "pxp", 
        "PixelPipeline Script", 
        "A scripting language for defining image processing pipelines.",
        "1.0.0", 
        "pxp", 
        dsl.defaultColorTheme(),
    )

    // By default your language can run all the functions
    // and use all the variables that have been defined below.
    //
    // If you ever need to reset the language to clear variables and functions
    // that have been added over time, you can do so by calling:
    //
    // l.restoreState()
    //
    // This will perform a full reset, which wipes all variables and
    // functions that have been created since the last time you called
    // l.vars.storeState() and l.funcs.storeState().
    //
    // You can also store the current state of the language by calling:
    //
    // l.storeState()

    // Register variables
    l.vars.storeState() // Store the state of variables, so we can reset the language without losing them

    // Register functions
    l.funcs.register("blend", "Blends the two images using the given blendmode (defaults to normal)",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
            { 
                name: "mode",
                typ:  "string", 
                def:  "normal", 
                desc: "The blendmode name",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blend(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64),
                a[2].(string), 
            )
        },
    )
    l.funcs.register("blend-normal", "Blends the two images using the normal blend mode (alpha compositing)",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendNormal(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-erase", "Erases the bottom image wherever the top image is present (destination out)",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendErase(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-multiply", "Blends the two images using the multiply blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendMultiply(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-screen", "Blends the two images using the screen blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendScreen(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-exclusion", "Blends the two images using the exclusion blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendExclusion(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-overlay", "Blends the two images using the overlay blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendOverlay(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-color-burn", "Blends the two images using the color burn blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendColorBurn(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-color-dodge", "Blends the two images using the color dodge blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendColorDodge(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-soft-light", "Blends the two images using the soft light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendSoftLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-hard-light", "Blends the two images using the hard light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendHardLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-difference", "Blends the two images using the difference blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendDifference(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-subtract", "Blends the two images using the subtract blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendSubtract(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-divide", "Blends the two images using the divide blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendDivide(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-hue", "Blends the two images using the hue blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendHue(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-saturation", "Blends the two images using the saturation blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendSaturation(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-color", "Blends the two images using the color blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendColor(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-luminosity", "Blends the two images using the luminosity blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendLuminosity(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-average", "Blends the two images using the average blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendAverage(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-negation", "Blends the two images using the negation blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendNegation(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-reflect", "Blends the two images using the reflect blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendReflect(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-glow", "Blends the two images using the glow blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendGlow(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-contrast-negate", "Blends the two images using the contrast negate blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendContrastNegate(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-vivid-light", "Blends the two images using the vivid light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendVividLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-linear-light", "Blends the two images using the linear light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendLinearLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-pin-light", "Blends the two images using the pin light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendPinLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-darken", "Blends the two images using the darken blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendDarken(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-darker-color", "Blends the two images using the darker color blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendDarkerColor(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-lighten", "Blends the two images using the lighten blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendLighten(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-lighter-color", "Blends the two images using the lighter color blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendLighterColor(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("blend-hard-mix", "Blends the two images using the hard mix blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendHardMix(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("hsla", "Creates a color from HSLA values",
        []dslParamMeta{ 
            { 
                name: "h",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The color's hue",
            },
            { 
                name: "s",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                unit: "\"%\"", 
                desc: "The color's saturation",
            },
            { 
                name: "l",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                unit: "\"%\"", 
                desc: "The color's luminosity",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return hsla(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("rgba", "Creates a color from RGBA values (8-bit per channel)",
        []dslParamMeta{ 
            { 
                name: "r",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  0, 
                unit: "\"\"", 
                desc: "The red component",
            },
            { 
                name: "g",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  0, 
                unit: "\"\"", 
                desc: "The green component",
            },
            { 
                name: "b",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  0, 
                unit: "\"\"", 
                desc: "The blue component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The alpha component",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return rgba(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("rgba64", "Creates a color from RGBA values (16-bit per channel)",
        []dslParamMeta{ 
            { 
                name: "r",
                typ:  "float64", 
                min:  0, 
                max:  65535, 
                def:  0, 
                unit: "\"\"", 
                desc: "The red component",
            },
            { 
                name: "g",
                typ:  "float64", 
                min:  0, 
                max:  65535, 
                def:  0, 
                unit: "\"\"", 
                desc: "The green component",
            },
            { 
                name: "b",
                typ:  "float64", 
                min:  0, 
                max:  65535, 
                def:  0, 
                unit: "\"\"", 
                desc: "The blue component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The alpha component",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return rgba64(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("cmyk", "Creates a color from CMYK values",
        []dslParamMeta{ 
            { 
                name: "c",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The cyan component",
            },
            { 
                name: "m",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The magenta component",
            },
            { 
                name: "y",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The yellow component",
            },
            { 
                name: "k",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The key (black) component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The alpha component",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return cmyk(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    l.funcs.register("hsv", "Creates a color from HSV values",
        []dslParamMeta{ 
            { 
                name: "h",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The color's hue",
            },
            { 
                name: "s",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                unit: "\"%\"", 
                desc: "The color's saturation",
            },
            { 
                name: "v",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                unit: "\"%\"", 
                desc: "The color's value (brightness)",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return hsv(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("lab", "Creates a color from CIELAB values",
        []dslParamMeta{ 
            { 
                name: "l",
                typ:  "float64", 
                min:  0, 
                max:  100, 
                def:  50, 
                unit: "\"\"", 
                desc: "The lightness component",
            },
            { 
                name: "a",
                typ:  "float64", 
                min:  -128, 
                max:  127, 
                def:  0, 
                unit: "\"\"", 
                desc: "The green-red component",
            },
            { 
                name: "b",
                typ:  "float64", 
                min:  -128, 
                max:  127, 
                def:  0, 
                unit: "\"\"", 
                desc: "The blue-yellow component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return lab(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("hwb", "Creates a color from HWB (Hue, Whiteness, Blackness) values",
        []dslParamMeta{ 
            { 
                name: "h",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The color's hue",
            },
            { 
                name: "w",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The whiteness component",
            },
            { 
                name: "b",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The blackness component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return hwb(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("xyz", "Creates a color from CIE XYZ values",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                min:  0, 
                max:  0.95047, 
                def:  0, 
                unit: "\"\"", 
                desc: "The X component (red)",
            },
            { 
                name: "y",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"\"", 
                desc: "The Y component (green)",
            },
            { 
                name: "z",
                typ:  "float64", 
                min:  0, 
                max:  1.08883, 
                def:  0, 
                unit: "\"\"", 
                desc: "The Z component (blue)",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return xyz(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("lch", "Creates a color from LCH (Lightness, Chroma, Hue) values",
        []dslParamMeta{ 
            { 
                name: "l",
                typ:  "float64", 
                min:  0, 
                max:  100, 
                def:  50, 
                unit: "\"\"", 
                desc: "The lightness component",
            },
            { 
                name: "c",
                typ:  "float64", 
                min:  0, 
                max:  128, 
                def:  0, 
                unit: "\"\"", 
                desc: "The chroma component",
            },
            { 
                name: "h",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The hue component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return lch(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("yuv", "Creates a color from YUV values",
        []dslParamMeta{ 
            { 
                name: "y",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"\"", 
                desc: "The luminance component",
            },
            { 
                name: "u",
                typ:  "float64", 
                min:  -0.436, 
                max:  0.436, 
                def:  0, 
                unit: "\"\"", 
                desc: "The U chrominance component",
            },
            { 
                name: "v",
                typ:  "float64", 
                min:  -0.615, 
                max:  0.615, 
                def:  0, 
                unit: "\"\"", 
                desc: "The V chrominance component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return yuv(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("ycbcr", "Creates a color from YCbCr values (digital video)",
        []dslParamMeta{ 
            { 
                name: "y",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  0, 
                unit: "\"\"", 
                desc: "The luminance component",
            },
            { 
                name: "cb",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  128, 
                unit: "\"\"", 
                desc: "The blue-difference chroma component",
            },
            { 
                name: "cr",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  128, 
                unit: "\"\"", 
                desc: "The red-difference chroma component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color",
            },
        },
        func(a ...any) (any, error) {
            return ycbcr(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("set-alpha", "Sets the alpha channel of a color",
        []dslParamMeta{ 
            { 
                name: "c",
                typ:  "color.RGBA64", 
                def:  "-", 
                unit: "\"\"", 
                desc: "The color to modify",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The new alpha value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color with new alpha",
            },
        },
        func(a ...any) (any, error) {
            return setAlpha(
                a[0].(color.RGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("map-color", "Maps a value to a color using color stops with HSLA interpolation",
        []dslParamMeta{ 
            { 
                name: "value",
                typ:  "float64", 
                def:  0, 
                unit: "\"\"", 
                desc: "The value to map to a color",
            },
            { 
                name: "min",
                typ:  "float64", 
                def:  0, 
                unit: "\"\"", 
                desc: "Minimum value of the range",
            },
            { 
                name: "max",
                typ:  "float64", 
                def:  1, 
                unit: "\"\"", 
                desc: "Maximum value of the range",
            },
            { 
                name: "stops",
                typ:  "[][]any", 
                def:  "-", 
                unit: "\"\"", 
                desc: "Color stops as [][]any where each stop is [threshold, hue, saturation, lightness, alpha]; threshold is a raw value between min and max",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The interpolated color",
            },
        },
        func(a ...any) (any, error) {
            return mapColor(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].([][]any), 
            )
        },
    )
    l.funcs.register("load-csv", "Loads a CSV file",
        []dslParamMeta{ 
            { 
                name: "path",
                typ:  "string", 
                def:  "-", 
                desc: "- - Path to the CSV file",
            },
            { 
                name: "sep",
                typ:  "string", 
                def:  "\\t", 
                desc: "The separator to split columns with",
            },
            { 
                name: "hasHeader",
                typ:  "bool", 
                def:  true, 
                desc: "Whether the first row is a header row",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A 2D slice with the data",
            },
        },
        func(a ...any) (any, error) {
            return loadCSV(
                a[0].(string),
                a[1].(string),
                a[2].(bool), 
            )
        },
    )
    l.funcs.register("load-csv-column", "Loads a column from a CSV file",
        []dslParamMeta{ 
            { 
                name: "path",
                typ:  "string", 
                def:  "-", 
                desc: "- - Path to the CSV file",
            },
            { 
                name: "index",
                typ:  "int", 
                def:  "-", 
                desc: "The index of the column to retrieve",
            },
            { 
                name: "sep",
                typ:  "string", 
                def:  "\\t", 
                desc: "The separator to split columns with",
            },
            { 
                name: "hasHeader",
                typ:  "bool", 
                def:  true, 
                desc: "Whether the first row is a header row",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A slice with the data",
            },
        },
        func(a ...any) (any, error) {
            return loadCSVColumn(
                a[0].(string),
                a[1].(int),
                a[2].(string),
                a[3].(bool), 
            )
        },
    )
    l.funcs.register("load-csv-row", "Loads a row from a CSV file",
        []dslParamMeta{ 
            { 
                name: "path",
                typ:  "string", 
                def:  "-", 
                desc: "- - Path to the CSV file",
            },
            { 
                name: "index",
                typ:  "int", 
                def:  "-", 
                desc: "The index of the row to retrieve",
            },
            { 
                name: "sep",
                typ:  "string", 
                def:  "\\t", 
                desc: "The separator to split columns with",
            },
            { 
                name: "hasHeader",
                typ:  "bool", 
                def:  true, 
                desc: "Whether the first row is a header row",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A slice with the data",
            },
        },
        func(a ...any) (any, error) {
            return loadCSVRow(
                a[0].(string),
                a[1].(int),
                a[2].(string),
                a[3].(bool), 
            )
        },
    )
    l.funcs.register("first-csv-row", "Returns the first row of CSV data",
        []dslParamMeta{ 
            { 
                name: "data",
                typ:  "[][]float64", 
                def:  "-", 
                desc: "Data to return first row of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A slice with the data",
            },
        },
        func(a ...any) (any, error) {
            return firstCSVRow(
                a[0].([][]float64), 
            )
        },
    )
    l.funcs.register("first-csv-rows", "Returns the first `n` rows of CSV data",
        []dslParamMeta{ 
            { 
                name: "data",
                typ:  "[][]float64", 
                def:  "-", 
                desc: "Data to return first `n` rows of",
            },
            { 
                name: "n",
                typ:  "int", 
                def:  1, 
                unit: "1", 
                desc: "Number rows to return",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A slice with the data",
            },
        },
        func(a ...any) (any, error) {
            return firstCSVRows(
                a[0].([][]float64),
                a[1].(int), 
            )
        },
    )
    l.funcs.register("last-csv-row", "Returns the last row of CSV data",
        []dslParamMeta{ 
            { 
                name: "data",
                typ:  "[][]float64", 
                def:  "-", 
                desc: "Data to return last row of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A slice with the data",
            },
        },
        func(a ...any) (any, error) {
            return lastCSVRow(
                a[0].([][]float64), 
            )
        },
    )
    l.funcs.register("last-csv-rows", "Returns the last `n` rows of CSV data",
        []dslParamMeta{ 
            { 
                name: "data",
                typ:  "[][]float64", 
                def:  "-", 
                desc: "Data to return last `n` rows of",
            },
            { 
                name: "n",
                typ:  "int", 
                def:  1, 
                unit: "1", 
                desc: "Number rows to return",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A slice with the data",
            },
        },
        func(a ...any) (any, error) {
            return lastCSVRows(
                a[0].([][]float64),
                a[1].(int), 
            )
        },
    )
    l.funcs.register("fill", "Fills the given image.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to fill",
            },
            { 
                name: "style",
                typ:  "FillStyle", 
                def:  "-", 
                desc: "The color of the fill",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The filled image",
            },
        },
        func(a ...any) (any, error) {
            return fill(
                a[0].(*image.NRGBA64),
                a[1].(FillStyle), 
            )
        },
    )
    l.funcs.register("border", "Draws a border around the image.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw border around",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the border",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return border(
                a[0].(*image.NRGBA64),
                a[1].(LineStyle), 
            )
        },
    )
    l.funcs.register("box", "Fills the image with the given background color and then draws a border around it.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw border around",
            },
            { 
                name: "styleBorder",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the border",
            },
            { 
                name: "styleFill",
                typ:  "FillStyle", 
                def:  "-", 
                desc: "The color of the fill",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return box(
                a[0].(*image.NRGBA64),
                a[1].(LineStyle),
                a[2].(FillStyle), 
            )
        },
    )
    l.funcs.register("grid", "Draws a grid from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "rows",
                typ:  "int", 
                def:  "-", 
                desc: "The number of rows",
            },
            { 
                name: "cols",
                typ:  "int", 
                def:  "-", 
                desc: "The number of cols",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the border",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return grid(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(int),
                a[3].(LineStyle), 
            )
        },
    )
    l.funcs.register("grid-v", "Draws vertical grid lines on the image with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "cols",
                typ:  "int", 
                def:  "-", 
                desc: "The number of columns",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the border",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return gridV(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("grid-h", "Draws horizontal grid lines on the image with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "rows",
                typ:  "int", 
                def:  "-", 
                desc: "The number of rows",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the border",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return gridH(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("group", "Generates the given group with the given styles.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to wrap in a group",
            },
            { 
                name: "title",
                typ:  "string", 
                def:  "-", 
                desc: "- - The title of the group",
            },
            { 
                name: "colTitle",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The color of the title",
            },
            { 
                name: "colHeader",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The color of the header",
            },
            { 
                name: "colBody",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The color of the body",
            },
            { 
                name: "colBorder",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The color of the border",
            },
            { 
                name: "padding",
                typ:  "int", 
                def:  3, 
                unit: "0", 
                desc: "The padding for the image to wrap",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The group wrapping the input image",
            },
        },
        func(a ...any) (any, error) {
            return group(
                a[0].(*image.NRGBA64),
                a[1].(string),
                a[2].(color.RGBA64),
                a[3].(color.RGBA64),
                a[4].(color.RGBA64),
                a[5].(color.RGBA64),
                a[6].(int), 
            )
        },
    )
    l.funcs.register("draw-circle", "Draws a circle.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "c",
                typ:  "Ellipse", 
                def:  "-", 
                desc: "The circle to draw",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawCircle(
                a[0].(*image.NRGBA64),
                a[1].(Ellipse),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-circle-px", "Draws a circle.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "c",
                typ:  "Ellipse", 
                def:  "-", 
                desc: "The circle to draw",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawCirclePx(
                a[0].(*image.NRGBA64),
                a[1].(Ellipse),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-ellipse", "Draws an ellipse.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "e",
                typ:  "Ellipse", 
                def:  "-", 
                desc: "The ellipse to draw",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawEllipse(
                a[0].(*image.NRGBA64),
                a[1].(Ellipse),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-ellipse-px", "Draws an ellipse.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "e",
                typ:  "Ellipse", 
                def:  "-", 
                desc: "The ellipse to draw",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawEllipsePx(
                a[0].(*image.NRGBA64),
                a[1].(Ellipse),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid", "Draws a grid from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The area to draw the grid on (relative)",
            },
            { 
                name: "rows",
                typ:  "int", 
                def:  "-", 
                desc: "The number of rows",
            },
            { 
                name: "cols",
                typ:  "int", 
                def:  "-", 
                desc: "The number of cols",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGrid(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(int),
                a[3].(int),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-h", "Draws a grid from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The area to draw the grid on (relative)",
            },
            { 
                name: "rows",
                typ:  "int", 
                def:  "-", 
                desc: "The number of rows",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridH(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(int),
                a[3].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-v", "Draws a grid from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The area to draw the grid on (relative)",
            },
            { 
                name: "cols",
                typ:  "int", 
                def:  "-", 
                desc: "The number of cols",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridV(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(int),
                a[3].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-px", "Draws a grid from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The area to draw the grid on",
            },
            { 
                name: "rows",
                typ:  "int", 
                def:  "-", 
                desc: "The number of rows",
            },
            { 
                name: "cols",
                typ:  "int", 
                def:  "-", 
                desc: "The number of cols",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridPx(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(int),
                a[3].(int),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-h-px", "Draws a grid from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The area to draw the grid on",
            },
            { 
                name: "rows",
                typ:  "int", 
                def:  "-", 
                desc: "The number of rows",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridHPx(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(int),
                a[3].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-v-px", "Draws a grid from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The area to draw the grid on",
            },
            { 
                name: "cols",
                typ:  "int", 
                def:  "-", 
                desc: "The number of cols",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridVPx(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(int),
                a[3].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line", "Draws a line from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "p1",
                typ:  "Point", 
                def:  "-", 
                desc: "The start position (relative)",
            },
            { 
                name: "p2",
                typ:  "Point", 
                def:  "-", 
                desc: "The end position (relative)",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLine(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(Point),
                a[3].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-v", "Draws a line from P(x|y1) to P(x|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The position on the x-axis (relative)",
            },
            { 
                name: "y1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start position on the y-axis (relative)",
            },
            { 
                name: "y2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end position on the y-axis (relative)",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLineVertical(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-h", "Draws a line from P(x1|y) to P(x2|y) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "y",
                typ:  "float64", 
                def:  "-", 
                desc: "The position on the y-axis (relative)",
            },
            { 
                name: "x1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start position on the x-axis (relative)",
            },
            { 
                name: "x2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end position on the x-axis (relative)",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLineHorizontal(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-px", "Draws a line from P(x1|y1) to P(x2|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "p1",
                typ:  "Point", 
                def:  "-", 
                desc: "The start position",
            },
            { 
                name: "p2",
                typ:  "Point", 
                def:  "-", 
                desc: "The end position",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLinePx(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(Point),
                a[3].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-v-px", "Draws a line from P(x|y1) to P(x|y2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The position on the x-axis",
            },
            { 
                name: "y1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start position on the y-axis",
            },
            { 
                name: "y2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end position on the y-axis",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLineVerticalPx(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-h-px", "Draws a line from P(x1|y) to P(x2|y) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "y",
                typ:  "float64", 
                def:  "-", 
                desc: "The position on the y-axis",
            },
            { 
                name: "x1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start position on the x-axis",
            },
            { 
                name: "x2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end position on the x-axis",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLineHorizontalPx(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-polar", "Draws a line from polar point P(r1|罐1) to P(r2|罐2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system (relative)",
            },
            { 
                name: "r1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start radius",
            },
            { 
                name: "theta1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start angle in radians",
            },
            { 
                name: "r2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end radius",
            },
            { 
                name: "theta2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end angle in radians",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLinePolar(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-polar-px", "Draws a line from polar point P(r1|罐1) to P(r2|罐2) with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system",
            },
            { 
                name: "r1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start radius",
            },
            { 
                name: "theta1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start angle in radians",
            },
            { 
                name: "r2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end radius",
            },
            { 
                name: "theta2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end angle in radians",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLinePolarPx(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-radial", "Draws a radial line from radius r1 to r2 at angle 罐 with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system (relative)",
            },
            { 
                name: "theta",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
            { 
                name: "r1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start radius",
            },
            { 
                name: "r2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end radius",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLineRadial(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-line-radial-px", "Draws a radial line from radius r1 to r2 at angle 罐 with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system",
            },
            { 
                name: "theta",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
            { 
                name: "r1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start radius",
            },
            { 
                name: "r2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end radius",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawLineRadialPx(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-arc", "Draws an arc at radius r from angle 罐1 to 罐2 with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system (relative)",
            },
            { 
                name: "r",
                typ:  "float64", 
                def:  "-", 
                desc: "The radius",
            },
            { 
                name: "theta1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start angle in radians",
            },
            { 
                name: "theta2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end angle in radians",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawArc(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-arc-px", "Draws an arc at radius r from angle 罐1 to 罐2 with the given thickness and color.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system",
            },
            { 
                name: "r",
                typ:  "float64", 
                def:  "-", 
                desc: "The radius",
            },
            { 
                name: "theta1",
                typ:  "float64", 
                def:  "-", 
                desc: "The start angle in radians",
            },
            { 
                name: "theta2",
                typ:  "float64", 
                def:  "-", 
                desc: "The end angle in radians",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawArcPx(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-polar", "Draws a polar grid with concentric circles and radial lines.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system (relative)",
            },
            { 
                name: "maxRadius",
                typ:  "float64", 
                def:  "-", 
                desc: "The maximum radius (relative)",
            },
            { 
                name: "circles",
                typ:  "int", 
                def:  "-", 
                desc: "The number of concentric circles",
            },
            { 
                name: "radials",
                typ:  "int", 
                def:  "-", 
                desc: "The number of radial lines",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridPolar(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(int),
                a[4].(int),
                a[5].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-polar-px", "Draws a polar grid with concentric circles and radial lines.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system",
            },
            { 
                name: "maxRadius",
                typ:  "float64", 
                def:  "-", 
                desc: "The maximum radius",
            },
            { 
                name: "circles",
                typ:  "int", 
                def:  "-", 
                desc: "The number of concentric circles",
            },
            { 
                name: "radials",
                typ:  "int", 
                def:  "-", 
                desc: "The number of radial lines",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridPolarPx(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(int),
                a[4].(int),
                a[5].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-radial", "Draws radial lines from the origin at evenly spaced angles.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system (relative)",
            },
            { 
                name: "maxRadius",
                typ:  "float64", 
                def:  "-", 
                desc: "The maximum radius (relative)",
            },
            { 
                name: "radials",
                typ:  "int", 
                def:  "-", 
                desc: "The number of radial lines",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridRadial(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(int),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-radial-px", "Draws radial lines from the origin at evenly spaced angles.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system",
            },
            { 
                name: "maxRadius",
                typ:  "float64", 
                def:  "-", 
                desc: "The maximum radius",
            },
            { 
                name: "radials",
                typ:  "int", 
                def:  "-", 
                desc: "The number of radial lines",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridRadialPx(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(int),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-concentric", "Draws concentric circles centered at the origin.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system (relative)",
            },
            { 
                name: "maxRadius",
                typ:  "float64", 
                def:  "-", 
                desc: "The maximum radius (relative)",
            },
            { 
                name: "circles",
                typ:  "int", 
                def:  "-", 
                desc: "The number of concentric circles",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridConcentric(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(int),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-grid-concentric-px", "Draws concentric circles centered at the origin.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "origin",
                typ:  "Point", 
                def:  "-", 
                desc: "The origin point for the polar coordinate system",
            },
            { 
                name: "maxRadius",
                typ:  "float64", 
                def:  "-", 
                desc: "The maximum radius",
            },
            { 
                name: "circles",
                typ:  "int", 
                def:  "-", 
                desc: "The number of concentric circles",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawGridConcentricPx(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(float64),
                a[3].(int),
                a[4].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-rect", "Draws a rectangle at position (x,y) with the given width and height.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The rectangle to draw (relative)",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawRect(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-square", "Draws a square at position (x,y) with the given size.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "s",
                typ:  "Rect", 
                def:  "-", 
                desc: "The square to draw (relative)",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawSquare(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-rect-px", "Draws a rectangle at position (x,y) with the given width and height.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The rectangle to draw (absolute)",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawRectPx(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-square-px", "Draws a square at position (x,y) with the given size.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "s",
                typ:  "Rect", 
                def:  "-", 
                desc: "The square to draw (absolute)",
            },
            { 
                name: "style",
                typ:  "LineStyle", 
                def:  "-", 
                desc: "The thickness and color of the line",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawSquarePx(
                a[0].(*image.NRGBA64),
                a[1].(Rect),
                a[2].(LineStyle), 
            )
        },
    )
    l.funcs.register("draw-text", "Draws a text at position (x,y).",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "p",
                typ:  "Point", 
                def:  "-", 
                desc: "The upper-left coordinate of the text",
            },
            { 
                name: "t",
                typ:  "string", 
                def:  "-", 
                desc: "- - The text to draw",
            },
            { 
                name: "colText",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The text color",
            },
            { 
                name: "colOutline",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The outline color",
            },
            { 
                name: "blendMode",
                typ:  "string", 
                def:  "normal", 
                desc: "The blend mode to use",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawText(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(string),
                a[3].(color.RGBA64),
                a[4].(color.RGBA64),
                a[5].(string), 
            )
        },
    )
    l.funcs.register("draw-text-px", "Draws text at position (x,y).",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to draw to",
            },
            { 
                name: "p",
                typ:  "Point", 
                def:  "-", 
                desc: "The upper-left coordinate of the text",
            },
            { 
                name: "t",
                typ:  "string", 
                def:  "-", 
                desc: "- - The text to draw",
            },
            { 
                name: "colText",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The text color",
            },
            { 
                name: "colOutline",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The outline color",
            },
            { 
                name: "blendMode",
                typ:  "string", 
                def:  "normal", 
                desc: "The blend mode to use",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return drawTextPx(
                a[0].(*image.NRGBA64),
                a[1].(Point),
                a[2].(string),
                a[3].(color.RGBA64),
                a[4].(color.RGBA64),
                a[5].(string), 
            )
        },
    )
    l.funcs.register("text", "Generates the given text.",
        []dslParamMeta{ 
            { 
                name: "t",
                typ:  "string", 
                def:  "-", 
                desc: "- - The text to generate",
            },
            { 
                name: "colText",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The text color",
            },
            { 
                name: "colOutline",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The outline color",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resulting image",
            },
        },
        func(a ...any) (any, error) {
            return text(
                a[0].(string),
                a[1].(color.RGBA64),
                a[2].(color.RGBA64), 
            )
        },
    )
    l.funcs.register("blur-gaussian", "Applies a Gaussian blur to the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to blur",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  1, 
                max:  10, 
                def:  1, 
                desc: "The blur radius (higher values create more blur)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blurred image",
            },
        },
        func(a ...any) (any, error) {
            return blurGaussian(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("blur-box", "Applies a box blur to an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to blur",
            },
            { 
                name: "radius",
                typ:  "int", 
                min:  1, 
                max:  10, 
                def:  1, 
                desc: "The blur radius (size of the box kernel)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blurred image",
            },
        },
        func(a ...any) (any, error) {
            return blurBox(
                a[0].(*image.NRGBA64),
                a[1].(int), 
            )
        },
    )
    l.funcs.register("blur-motion", "Applies a motion blur to an image along a specified angle.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to blur",
            },
            { 
                name: "length",
                typ:  "int", 
                min:  1, 
                max:  100, 
                def:  5, 
                desc: "The length of the motion blur (in pixels)",
            },
            { 
                name: "angle",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                desc: "The angle of the motion blur (in degrees)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blurred image",
            },
        },
        func(a ...any) (any, error) {
            return blurMotion(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("blur-zoom", "Applies a zoom blur effect to an image.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to blur",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.25, 
                desc: "The strength of the blur effect (higher means more blur)",
            },
            { 
                name: "centerX",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "X coordinate of the blur center (default: image center)",
            },
            { 
                name: "centerY",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "Y coordinate of the blur center (default: image center)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The blurred image",
            },
        },
        func(a ...any) (any, error) {
            return blurZoom(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("invert", "Inverts an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to invert",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The inverted image",
            },
        },
        func(a ...any) (any, error) {
            return colorInvert(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("grayscale", "Grayscales an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to grayscale",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The grayscaled image",
            },
        },
        func(a ...any) (any, error) {
            return colorGrayscale(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("sepia", "Changes the tone of an image to sepia",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to change to sepia tone",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The sepia-toned image",
            },
        },
        func(a ...any) (any, error) {
            return colorSepia(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("brightness", "Changes the brightness of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to change brightness of",
            },
            { 
                name: "factor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  0, 
                desc: "The change factor",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with brightness changed",
            },
        },
        func(a ...any) (any, error) {
            return colorBrightness(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("colorize", "Colorizes the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to colorize",
            },
            { 
                name: "col",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The color that determines the hue to use for colorization",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The colorized image",
            },
        },
        func(a ...any) (any, error) {
            return colorColorize(
                a[0].(*image.NRGBA64),
                a[1].(color.RGBA64), 
            )
        },
    )
    l.funcs.register("contrast", "Adjusts the contrast of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust contrast of",
            },
            { 
                name: "factor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "The contrast factor (0 = gray, 1 = unchanged, 2 = maximum)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The contrast-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorContrast(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("saturation", "Adjusts the color saturation of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust saturation of",
            },
            { 
                name: "factor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "The saturation factor (0 = grayscale, 1 = unchanged, 2 = super saturated)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The saturation-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorSaturation(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("opacity", "Adjusts the overall opacity/transparency of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust opacity of",
            },
            { 
                name: "amount",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The opacity amount (0 = fully transparent, 1 = unchanged)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The opacity-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorOpacity(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("chromatic-aberration", "Creates a chromatic aberration effect by offsetting color channels",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to apply the effect to",
            },
            { 
                name: "amount",
                typ:  "float64", 
                min:  0, 
                max:  20, 
                def:  5, 
                desc: "The amount of color channel separation",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with chromatic aberration",
            },
        },
        func(a ...any) (any, error) {
            return colorChromaticAberration(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("hue-rotate", "Rotates the hue of image colors",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to rotate hue of",
            },
            { 
                name: "angle",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The angle in degrees (0-360)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The hue-rotated image",
            },
        },
        func(a ...any) (any, error) {
            return colorHueRotate(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("color-balance", "Adjusts the balance of Red, Green, and Blue channels",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust color balance of",
            },
            { 
                name: "rFactor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "Red channel adjustment factor",
            },
            { 
                name: "gFactor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "Green channel adjustment factor",
            },
            { 
                name: "bFactor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "Blue channel adjustment factor",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The color-balanced image",
            },
        },
        func(a ...any) (any, error) {
            return colorBalance(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("posterize", "Reduces the number of color levels in the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to posterize",
            },
            { 
                name: "levels",
                typ:  "int", 
                min:  2, 
                max:  16, 
                def:  4, 
                desc: "Number of color levels per channel (2-16)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The posterized image",
            },
        },
        func(a ...any) (any, error) {
            return colorPosterize(
                a[0].(*image.NRGBA64),
                a[1].(int), 
            )
        },
    )
    l.funcs.register("threshold", "Converts image to black and white based on a brightness threshold",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to apply thresholding to",
            },
            { 
                name: "level",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "The brightness threshold",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The thresholded (black and white) image",
            },
        },
        func(a ...any) (any, error) {
            return colorThreshold(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("edge-detect", "Detects edges in the image using the Sobel operator",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to detect edges in",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - An image highlighting the edges",
            },
        },
        func(a ...any) (any, error) {
            return colorEdgeDetect(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("vignette", "Adds a vignette effect (darkens/lightens edges)",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to apply vignette to",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "Darkness/Lightness intensity (0 to 1)",
            },
            { 
                name: "falloff",
                typ:  "float64", 
                min:  0.1, 
                max:  2, 
                def:  0.8, 
                desc: "How quickly the effect fades (0.1 to 2.0)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with vignette effect",
            },
        },
        func(a ...any) (any, error) {
            return colorVignette(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("vibrance", "Adjusts the saturation of an image, protecting already saturated colors and skin tones.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust vibrance of",
            },
            { 
                name: "factor",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "The vibrance adjustment factor (-1 = less vibrant, 0 = unchanged, 1 = more vibrant)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The vibrance-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorVibrance(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("exposure", "Adjusts the overall lightness or darkness of the image, simulating photographic exposure.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust exposure of",
            },
            { 
                name: "level",
                typ:  "float64", 
                min:  -2, 
                max:  2, 
                def:  0, 
                desc: "The exposure level adjustment (-2 = much darker, 0 = unchanged, 2 = much brighter)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The exposure-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorExposure(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("select-hue", "Selects a specific hue from the image and makes everything else transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "hue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The target hue to keep (in degrees)",
            },
            { 
                name: "toleranceLeft",
                typ:  "float64", 
                min:  0, 
                max:  180, 
                def:  30, 
                unit: "\"째\"", 
                desc: "How much to include to the left (lower hue, in degrees)",
            },
            { 
                name: "toleranceRight",
                typ:  "float64", 
                min:  0, 
                max:  180, 
                def:  30, 
                unit: "\"째\"", 
                desc: "How much to include to the right (higher hue, in degrees)",
            },
            { 
                name: "softness",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "How soft the transition should be (0 = hard cut, 1 = very soft)",
            },
            { 
                name: "minSaturation",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.15, 
                desc: "The minimum saturation required to keep a pixel (smooth fade below)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with only the selected hue visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorSelectHue(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    l.funcs.register("select-hsl", "Selects pixels based on their hue, saturation, and luminance, making pixels outside the specified ranges transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "minHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  30, 
                unit: "\"째\"", 
                desc: "The minimum hue for full opacity (fade from 0% to 100% between lowerHue and this)",
            },
            { 
                name: "maxHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  330, 
                unit: "\"째\"", 
                desc: "The maximum hue for full opacity (fade from 100% to 0% between this and upperHue)",
            },
            { 
                name: "upperHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  360, 
                unit: "\"째\"", 
                desc: "The upper hue threshold (above this becomes transparent)",
            },
            { 
                name: "lowerSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower saturation threshold (below this becomes transparent)",
            },
            { 
                name: "minSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum saturation for full opacity (fade from 0% to 100% between lowerSat and this)",
            },
            { 
                name: "maxSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum saturation for full opacity (fade from 100% to 0% between this and upperSat)",
            },
            { 
                name: "upperSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper saturation threshold (above this becomes transparent)",
            },
            { 
                name: "lowerLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower luminance threshold (below this becomes transparent)",
            },
            { 
                name: "minLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum luminance for full opacity (fade from 0% to 100% between lowerLum and this)",
            },
            { 
                name: "maxLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum luminance for full opacity (fade from 100% to 0% between this and upperLum)",
            },
            { 
                name: "upperLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper luminance threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with only pixels in all specified ranges visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorSelectHSL(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64), 
            )
        },
    )
    l.funcs.register("remove-hsl", "Removes pixels based on their hue, saturation, and luminance, making pixels inside the specified ranges transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "minHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  30, 
                unit: "\"째\"", 
                desc: "The minimum hue for full opacity (fade from 0% to 100% between lowerHue and this)",
            },
            { 
                name: "maxHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  330, 
                unit: "\"째\"", 
                desc: "The maximum hue for full opacity (fade from 100% to 0% between this and upperHue)",
            },
            { 
                name: "upperHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  360, 
                unit: "\"째\"", 
                desc: "The upper hue threshold (above this becomes transparent)",
            },
            { 
                name: "lowerSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower saturation threshold (below this becomes transparent)",
            },
            { 
                name: "minSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum saturation for full opacity (fade from 0% to 100% between lowerSat and this)",
            },
            { 
                name: "maxSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum saturation for full opacity (fade from 100% to 0% between this and upperSat)",
            },
            { 
                name: "upperSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper saturation threshold (above this becomes transparent)",
            },
            { 
                name: "lowerLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower luminance threshold (below this becomes transparent)",
            },
            { 
                name: "minLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum luminance for full opacity (fade from 0% to 100% between lowerLum and this)",
            },
            { 
                name: "maxLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum luminance for full opacity (fade from 100% to 0% between this and upperLum)",
            },
            { 
                name: "upperLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper luminance threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with only pixels in all specified ranges visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorRemoveHSL(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64), 
            )
        },
    )
    l.funcs.register("invert-hsl", "Inverts pixels based on their hue, saturation, and luminance, inverting pixels inside the specified ranges",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "minHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  30, 
                unit: "\"째\"", 
                desc: "The minimum hue for full opacity (fade from 0% to 100% between lowerHue and this)",
            },
            { 
                name: "maxHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  330, 
                unit: "\"째\"", 
                desc: "The maximum hue for full opacity (fade from 100% to 0% between this and upperHue)",
            },
            { 
                name: "upperHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  360, 
                unit: "\"째\"", 
                desc: "The upper hue threshold (above this becomes transparent)",
            },
            { 
                name: "lowerSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower saturation threshold (below this becomes transparent)",
            },
            { 
                name: "minSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum saturation for full opacity (fade from 0% to 100% between lowerSat and this)",
            },
            { 
                name: "maxSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum saturation for full opacity (fade from 100% to 0% between this and upperSat)",
            },
            { 
                name: "upperSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper saturation threshold (above this becomes transparent)",
            },
            { 
                name: "lowerLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower luminance threshold (below this becomes transparent)",
            },
            { 
                name: "minLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum luminance for full opacity (fade from 0% to 100% between lowerLum and this)",
            },
            { 
                name: "maxLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum luminance for full opacity (fade from 100% to 0% between this and upperLum)",
            },
            { 
                name: "upperLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper luminance threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with only pixels in all specified ranges visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorInvertHSL(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64), 
            )
        },
    )
    l.funcs.register("rotate-hsl", "Rotates the hue of pixels based on their hue, saturation, and luminance",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "rotate",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "lowerHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "minHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  30, 
                unit: "\"째\"", 
                desc: "The minimum hue for full opacity (fade from 0% to 100% between lowerHue and this)",
            },
            { 
                name: "maxHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  330, 
                unit: "\"째\"", 
                desc: "The maximum hue for full opacity (fade from 100% to 0% between this and upperHue)",
            },
            { 
                name: "upperHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  360, 
                unit: "\"째\"", 
                desc: "The upper hue threshold (above this becomes transparent)",
            },
            { 
                name: "lowerSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower saturation threshold (below this becomes transparent)",
            },
            { 
                name: "minSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum saturation for full opacity (fade from 0% to 100% between lowerSat and this)",
            },
            { 
                name: "maxSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum saturation for full opacity (fade from 100% to 0% between this and upperSat)",
            },
            { 
                name: "upperSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper saturation threshold (above this becomes transparent)",
            },
            { 
                name: "lowerLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower luminance threshold (below this becomes transparent)",
            },
            { 
                name: "minLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum luminance for full opacity (fade from 0% to 100% between lowerLum and this)",
            },
            { 
                name: "maxLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum luminance for full opacity (fade from 100% to 0% between this and upperLum)",
            },
            { 
                name: "upperLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper luminance threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with only pixels in all specified ranges visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorRotateHSL(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64),
                a[13].(float64), 
            )
        },
    )
    l.funcs.register("auto-levels", "Automatically adjusts the contrast and brightness of an image by stretching the histogram to use the full range of values, ignoring outliers using percentiles",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to auto-level",
            },
            { 
                name: "lowPercentile",
                typ:  "float64", 
                def:  0.05, 
                unit: "%", 
                desc: "The lower percentile to ignore (e.g., 0.5)",
            },
            { 
                name: "highPercentile",
                typ:  "float64", 
                def:  0.995, 
                unit: "%", 
                desc: "The upper percentile to ignore (e.g., 99.5)",
            },
            { 
                name: "adjustAlpha",
                typ:  "bool", 
                def:  false, 
                desc: "Whether to adjust alpha channel (false = preserve original alpha)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The auto-leveled image",
            },
        },
        func(a ...any) (any, error) {
            return colorAutoLevels(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(bool), 
            )
        },
    )
    l.funcs.register("auto-white-balance", "Automatically adjusts the white balance of an image by finding bright areas and making them neutral",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to auto-white-balance",
            },
            { 
                name: "threshold",
                typ:  "float64", 
                def:  0.95, 
                unit: "%", 
                desc: "The brightness threshold to consider as white (0-1)",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "How strongly to apply the white balance (0 = no change, 1 = full correction)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The white-balanced image",
            },
        },
        func(a ...any) (any, error) {
            return colorAutoWhiteBalance(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("auto-contrast", "Automatically adjusts the contrast of an image by stretching the histogram to use the full range of values",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to auto-contrast",
            },
            { 
                name: "threshold",
                typ:  "float64", 
                def:  0.01, 
                unit: "%", 
                desc: "The percentage of pixels to ignore at both ends of the histogram (0-0.5)",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "How strongly to apply the contrast adjustment (0 = no change, 1 = full correction)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The contrast-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorAutoContrast(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("auto-tone", "Automatically enhances the image by applying auto-levels, auto-white-balance, and auto-contrast in sequence",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to auto-tone",
            },
            { 
                name: "levelsLow",
                typ:  "float64", 
                def:  0.005, 
                unit: "%", 
                desc: "Lower percentile for auto-levels (e.g., 0.5)",
            },
            { 
                name: "levelsHigh",
                typ:  "float64", 
                def:  0.9995, 
                unit: "%", 
                desc: "Upper percentile for auto-levels (e.g., 99.5)",
            },
            { 
                name: "whiteThresh",
                typ:  "float64", 
                def:  0.99, 
                unit: "%", 
                desc: "Brightness threshold for auto-white-balance (0-1)",
            },
            { 
                name: "whiteStrength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "Strength for auto-white-balance (0-1)",
            },
            { 
                name: "contrastThresh",
                typ:  "float64", 
                def:  0.01, 
                unit: "%", 
                desc: "Percentile for auto-contrast (0-0.5)",
            },
            { 
                name: "contrastStrength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "Strength for auto-contrast (0-1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The auto-toned image",
            },
        },
        func(a ...any) (any, error) {
            return colorAutoTone(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64), 
            )
        },
    )
    l.funcs.register("select-brightness", "Selects pixels based on their brightness, making pixels outside the specified range transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower brightness threshold (below this becomes transparent)",
            },
            { 
                name: "minBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum brightness for full opacity (fade from 0% to 100% between lowerBright and this)",
            },
            { 
                name: "maxBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum brightness for full opacity (fade from 100% to 0% between this and upperBright)",
            },
            { 
                name: "upperBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper brightness threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with only pixels in the specified brightness range visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorSelectBrightness(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    l.funcs.register("remove-brightness", "Removes pixels based on their brightness, making pixels inside the specified range transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower brightness threshold (below this becomes transparent)",
            },
            { 
                name: "minBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum brightness for full opacity (fade from 0% to 100% between lowerBright and this)",
            },
            { 
                name: "maxBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum brightness for full opacity (fade from 100% to 0% between this and upperBright)",
            },
            { 
                name: "upperBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper brightness threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The image with pixels in the specified brightness range removed (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorRemoveBrightness(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    l.funcs.register("remap-color", "Remaps image colors from source color stops to target color stops",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to remap",
            },
            { 
                name: "sourceStops",
                typ:  "[][]any", 
                def:  "-", 
                unit: "\"\"", 
                desc: "Source color stops as [][]any where each stop is [threshold, hue, saturation, lightness, alpha]",
            },
            { 
                name: "targetStops",
                typ:  "[][]any", 
                def:  "-", 
                unit: "\"\"", 
                desc: "Target color stops as [][]any where each stop is [threshold, hue, saturation, lightness, alpha]",
            },
            { 
                name: "tolerance",
                typ:  "float64", 
                def:  2.5, 
                unit: "\"\"", 
                desc: "Tolerance for color matching (higher = more forgiving, reduces artifacts from compression)",
            },
            { 
                name: "precision",
                typ:  "float64", 
                def:  1, 
                unit: "\"\"", 
                desc: "Precision multiplier for color bar size (1 = max(width,height), 2 = 2x, 3 = 3x, etc.)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The remapped image",
            },
        },
        func(a ...any) (any, error) {
            return colorRemap(
                a[0].(*image.NRGBA64),
                a[1].([][]any),
                a[2].([][]any),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    l.funcs.register("remap-bw", "Remaps image colors from source color stops to grayscale",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to remap",
            },
            { 
                name: "sourceStops",
                typ:  "[][]any", 
                def:  "-", 
                unit: "\"\"", 
                desc: "Source color stops as [][]any where each stop is [threshold, hue, saturation, lightness, alpha]",
            },
            { 
                name: "tolerance",
                typ:  "float64", 
                def:  2.5, 
                unit: "\"\"", 
                desc: "Tolerance for color matching (higher = more forgiving, reduces artifacts from compression)",
            },
            { 
                name: "precision",
                typ:  "float64", 
                def:  1, 
                unit: "\"\"", 
                desc: "Precision multiplier for color bar size (1 = max(width,height), 2 = 2x, 3 = 3x, etc.)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The remapped image",
            },
        },
        func(a ...any) (any, error) {
            return bwRemap(
                a[0].(*image.NRGBA64),
                a[1].([][]any),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("rectangular-to-polar", "Converts a rectangular coordinate image to polar coordinates",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to transform",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The transformed image",
            },
        },
        func(a ...any) (any, error) {
            return distortRectangularToPolar(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("polar-to-rectangular", "Converts a polar coordinate image to rectangular coordinates",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to transform",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The transformed image",
            },
        },
        func(a ...any) (any, error) {
            return distortPolarToRectangular(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("pixelate", "Creates a pixelation effect by averaging colors in blocks",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to pixelate",
            },
            { 
                name: "size",
                typ:  "int", 
                min:  1, 
                max:  50, 
                def:  8, 
                desc: "The size of the pixel blocks",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The pixelated image",
            },
        },
        func(a ...any) (any, error) {
            return distortPixelate(
                a[0].(*image.NRGBA64),
                a[1].(int), 
            )
        },
    )
    l.funcs.register("displace", "Displaces pixels based on the brightness of a displacement map",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to displace",
            },
            { 
                name: "dMap",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The displacement map image",
            },
            { 
                name: "amount",
                typ:  "float64", 
                min:  0, 
                max:  50, 
                def:  10, 
                desc: "The amount of displacement",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The displaced image",
            },
        },
        func(a ...any) (any, error) {
            return distortDisplace(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("defisheye", "Corrects fisheye lens distortion in an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to correct",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "The strength of the correction",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The corrected image",
            },
        },
        func(a ...any) (any, error) {
            return distortDefisheye(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("fisheye", "Applies a fisheye lens distortion effect to the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to distort",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "The strength of the fisheye effect",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The distorted image",
            },
        },
        func(a ...any) (any, error) {
            return distortFisheye(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("enhance", "Enhances colors and sharpness of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to enhance",
            },
            { 
                name: "brightness",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "The brightness adjustment of the image",
            },
            { 
                name: "contrast",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "The contrast adjustment of the image",
            },
            { 
                name: "sharpening",
                typ:  "float64", 
                min:  0, 
                max:  5, 
                def:  1, 
                desc: "The sharpening intensity in pixels (higher values detect larger edges)",
            },
            { 
                name: "rMin",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.75, 
                desc: "The minimum intensity of the red channel",
            },
            { 
                name: "rMax",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The maximum intensity of the red channel",
            },
            { 
                name: "gMin",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.75, 
                desc: "The minimum intensity of the green channel",
            },
            { 
                name: "gMax",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The maximum intensity of the green channel",
            },
            { 
                name: "bMin",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.75, 
                desc: "The minimum intensity of the blue channel",
            },
            { 
                name: "bMax",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The maximum intensity of the blue channel",
            },
            { 
                name: "rWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.299, 
                desc: "The weight of the red channel (used for sharpening)",
            },
            { 
                name: "gWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.587, 
                desc: "The weight of the green channel (used for sharpening)",
            },
            { 
                name: "bWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.114, 
                desc: "The weight of the blue channel (used for sharpening)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The enhanceed image",
            },
        },
        func(a ...any) (any, error) {
            return enhance(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64), 
            )
        },
    )
    l.funcs.register("sharpen", "Sharpens an image using a highpass combined with vivid light blending",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to sharpen",
            },
            { 
                name: "intensity",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The intensity of the sharpening effect",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0.1, 
                max:  2, 
                def:  1, 
                desc: "The radius of the filter in pixels (higher values detect larger edges)",
            },
            { 
                name: "rWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.299, 
                desc: "The weight of the red channel",
            },
            { 
                name: "gWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.587, 
                desc: "The weight of the green channel",
            },
            { 
                name: "bWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.114, 
                desc: "The weight of the blue channel",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The sharpened image",
            },
        },
        func(a ...any) (any, error) {
            return sharpen(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    l.funcs.register("highpass", "Creates a high pass filter effect, resulting in a gray image with embossed edges",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to apply the high-pass filter to",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0.1, 
                max:  2, 
                def:  1, 
                desc: "The radius of the filter in pixels (higher values detect larger edges)",
            },
            { 
                name: "rWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.299, 
                desc: "The weight of the red channel",
            },
            { 
                name: "gWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.587, 
                desc: "The weight of the green channel",
            },
            { 
                name: "bWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.114, 
                desc: "The weight of the blue channel",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The filtered image",
            },
        },
        func(a ...any) (any, error) {
            return sharpenHighpass(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    l.funcs.register("clarity", "Enhances local contrast while preserving overall image structure",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to enhance",
            },
            { 
                name: "intensity",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The intensity of the clarity effect",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0.1, 
                max:  2, 
                def:  1, 
                desc: "The radius of the filter in pixels (higher values affect larger areas)",
            },
            { 
                name: "rWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.299, 
                desc: "The weight of the red channel",
            },
            { 
                name: "gWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.587, 
                desc: "The weight of the green channel",
            },
            { 
                name: "bWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.114, 
                desc: "The weight of the blue channel",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The enhanced image",
            },
        },
        func(a ...any) (any, error) {
            return clarity(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    l.funcs.register("translate", "Translates (moves) an image by a specified amount",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to translate",
            },
            { 
                name: "dx",
                typ:  "float64", 
                def:  0, 
                desc: "The horizontal translation amount in % (positive = right)",
            },
            { 
                name: "dy",
                typ:  "float64", 
                def:  0, 
                desc: "The vertical translation amount in % (positive = down)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The translated image",
            },
        },
        func(a ...any) (any, error) {
            return translate(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("rotate", "Rotates an image around its center by a specified angle",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to rotate",
            },
            { 
                name: "angle",
                typ:  "float64", 
                min:  -360, 
                max:  360, 
                def:  0, 
                desc: "The rotation angle in degrees (positive = clockwise)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The rotated image",
            },
        },
        func(a ...any) (any, error) {
            return rotate(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("scale", "Scales an image by specified factors",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to scale",
            },
            { 
                name: "sx",
                typ:  "float64", 
                def:  0, 
                desc: "The horizontal scale factor",
            },
            { 
                name: "sy",
                typ:  "float64", 
                def:  0, 
                desc: "The vertical scale factor",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The scaled image",
            },
        },
        func(a ...any) (any, error) {
            return scale(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("transform", "Applies translation, rotation, and scaling to an image in one operation",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to transform",
            },
            { 
                name: "dx",
                typ:  "float64", 
                def:  0, 
                desc: "The horizontal translation in pixels",
            },
            { 
                name: "dy",
                typ:  "float64", 
                def:  0, 
                desc: "The vertical translation in pixels",
            },
            { 
                name: "angle",
                typ:  "float64", 
                def:  0, 
                desc: "The rotation angle in degrees (clockwise)",
            },
            { 
                name: "sx",
                typ:  "float64", 
                def:  0, 
                desc: "The horizontal scale factor",
            },
            { 
                name: "sy",
                typ:  "float64", 
                def:  0, 
                desc: "The vertical scale factor",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The transformed image",
            },
        },
        func(a ...any) (any, error) {
            return transform(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    l.funcs.register("flip-v", "Flips an image vertically (top to bottom)",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to flip vertically",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The vertically flipped image",
            },
        },
        func(a ...any) (any, error) {
            return flipVertical(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("flip-h", "Flips an image horizontally (left to right)",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to flip horizontally",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The horizontally flipped image",
            },
        },
        func(a ...any) (any, error) {
            return flipHorizontal(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("crop", "Crops an image by specified percentages from each side",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "left",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to crop from the left side (0-1)",
            },
            { 
                name: "right",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to crop from the right side (0-1)",
            },
            { 
                name: "top",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to crop from the top side (0-1)",
            },
            { 
                name: "bottom",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to crop from the bottom side (0-1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The cropped image",
            },
        },
        func(a ...any) (any, error) {
            return crop(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    l.funcs.register("crop-px", "Crops an image by specified amounts of pixels from each side",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "left",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to crop from the left side",
            },
            { 
                name: "right",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to crop from the right side",
            },
            { 
                name: "top",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to crop from the top side",
            },
            { 
                name: "bottom",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to crop from the bottom side",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The cropped image",
            },
        },
        func(a ...any) (any, error) {
            return cropPx(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(int),
                a[3].(int),
                a[4].(int), 
            )
        },
    )
    l.funcs.register("crop-circle", "Crops an image using a circular mask. The circle is centered at (centerX+offsetX, centerY+offsetY) and the radius is a percentage (0-1) of half the minimum image dimension.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Radius as a percentage of half the min(width, height)",
            },
            { 
                name: "offsetX",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Horizontal offset from image center (percentage of width, -1..1)",
            },
            { 
                name: "offsetY",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Vertical offset from image center (percentage of height, -1..1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The circularly cropped image (pixels outside the circle are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropCircle(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("crop-circle-px", "Crops an image using a circular mask. The circle is centered at (centerX+offsetX, centerY+offsetY) and the radius is a percentage (0-1) of half the minimum image dimension.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Radius as a percentage of half the min(width, height)",
            },
            { 
                name: "offsetX",
                typ:  "float64", 
                def:  0, 
                desc: "Horizontal offset from image center (pixels)",
            },
            { 
                name: "offsetY",
                typ:  "float64", 
                def:  0, 
                desc: "Vertical offset from image center (pixels)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The circularly cropped image (pixels outside the circle are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropCirclePx(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("crop-square", "Crops an image using a square mask. The square is centered at (centerX+offsetX, centerY+offsetY) and the size is a percentage (0-1) of the minimum image dimension.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "size",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Size as a percentage of the min(width, height)",
            },
            { 
                name: "offsetX",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Horizontal offset from image center (percentage of width, -1..1)",
            },
            { 
                name: "offsetY",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Vertical offset from image center (percentage of height, -1..1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The square-cropped image (pixels outside the square are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropSquare(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("crop-square-px", "Crops an image using a square mask. The square is centered at (centerX+offsetX, centerY+offsetY) and the size is a percentage (0-1) of the minimum image dimension.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "size",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Size as a percentage of the min(width, height)",
            },
            { 
                name: "offsetX",
                typ:  "int", 
                def:  0, 
                desc: "Horizontal offset from image center (pixels)",
            },
            { 
                name: "offsetY",
                typ:  "int", 
                def:  0, 
                desc: "Vertical offset from image center (pixels)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The square-cropped image (pixels outside the square are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropSquarePx(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(int),
                a[3].(int), 
            )
        },
    )
    l.funcs.register("crop-arc", "Crops an image using an arc mask. The arc is a portion of a circle centered at (centerX+offsetX, centerY+offsetY) with the radius as a percentage (0-1) of half the minimum image dimension. Only pixels within the arc angle range are kept.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Radius as a percentage of half the min(width, height)",
            },
            { 
                name: "startAngle",
                typ:  "float64", 
                min:  -360, 
                max:  360, 
                def:  0, 
                desc: "Starting angle of the arc in degrees (-360 to 360, clockwise from right)",
            },
            { 
                name: "endAngle",
                typ:  "float64", 
                min:  -360, 
                max:  360, 
                def:  360, 
                desc: "Ending angle of the arc in degrees (-360 to 360, clockwise from right)",
            },
            { 
                name: "offsetX",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Horizontal offset from image center (percentage of width, -1..1)",
            },
            { 
                name: "offsetY",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Vertical offset from image center (percentage of height, -1..1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The arc-cropped image (pixels outside the arc are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropArc(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    l.funcs.register("crop-arc-px", "Crops an image using an arc mask. The arc is a portion of a circle centered at (centerX+offsetX, centerY+offsetY) with the radius as a percentage (0-1) of half the minimum image dimension. Only pixels within the arc angle range are kept.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Radius as a percentage of half the min(width, height)",
            },
            { 
                name: "startAngle",
                typ:  "float64", 
                min:  -360, 
                max:  360, 
                def:  0, 
                desc: "Starting angle of the arc in degrees (-360 to 360, clockwise from right)",
            },
            { 
                name: "endAngle",
                typ:  "float64", 
                min:  -360, 
                max:  360, 
                def:  360, 
                desc: "Ending angle of the arc in degrees (-360 to 360, clockwise from right)",
            },
            { 
                name: "offsetX",
                typ:  "float64", 
                def:  0, 
                desc: "Horizontal offset from image center (pixels)",
            },
            { 
                name: "offsetY",
                typ:  "float64", 
                def:  0, 
                desc: "Vertical offset from image center (pixels)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The arc-cropped image (pixels outside the arc are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropArcPx(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    l.funcs.register("expand", "Expands an image by adding transparent borders with specified percentage widths",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to expand",
            },
            { 
                name: "left",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to add to the left side (relative to original width)",
            },
            { 
                name: "right",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to add to the right side (relative to original width)",
            },
            { 
                name: "top",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to add to the top side (relative to original height)",
            },
            { 
                name: "bottom",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to add to the bottom side (relative to original height)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The expanded image",
            },
        },
        func(a ...any) (any, error) {
            return expand(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    l.funcs.register("expand-px", "Expands an image by adding transparent borders with specified pixel widths",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to expand",
            },
            { 
                name: "left",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to add to the left side",
            },
            { 
                name: "right",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to add to the right side",
            },
            { 
                name: "top",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to add to the top side",
            },
            { 
                name: "bottom",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to add to the bottom side",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The expanded image",
            },
        },
        func(a ...any) (any, error) {
            return expandPx(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(int),
                a[3].(int),
                a[4].(int), 
            )
        },
    )
    l.funcs.register("resize-max-mp", "Resize an image to stay within a maximum amount of megapixels",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to resize",
            },
            { 
                name: "mpMax",
                typ:  "int", 
                def:  0, 
                desc: "The maximum amount of megapixels",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resized image",
            },
        },
        func(a ...any) (any, error) {
            return resizeToMaxMP(
                a[0].(*image.NRGBA64),
                a[1].(int), 
            )
        },
    )
    l.funcs.register("resize-fit", "Resize an image to fit within a bounding box while preserving aspect ratio",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to resize",
            },
            { 
                name: "maxW",
                typ:  "int", 
                def:  0, 
                desc: "The maximum width (pixels)",
            },
            { 
                name: "maxH",
                typ:  "int", 
                def:  0, 
                desc: "The maximum height (pixels)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The resized image",
            },
        },
        func(a ...any) (any, error) {
            return resizeToFit(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(int), 
            )
        },
    )
    l.funcs.register("It", "Translates the given image by expanding/cropping the left + top borders.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to translate",
            },
            { 
                name: "dt",
                typ:  "Point", 
                def:  "-", 
                desc: "The translation to apply",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The new image",
            },
        },
        func(a ...any) (any, error) {
            return translateImage(
                a[0].(*image.NRGBA64),
                a[1].(Point), 
            )
        },
    )
    l.funcs.register("blend-aligned", "Aligns two images using the given anchor (left-top, top, top-right, left, center, right, bottom-left, bottom, bottom-right) and blends them using the given blendmode (defaults to normal).",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
            { 
                name: "anchor",
                typ:  "string", 
                def:  "C", 
                desc: "The anchor to align to (TL, T, TR, L, C, R, BL, B, BR)",
            },
            { 
                name: "mode",
                typ:  "string", 
                def:  "normal", 
                desc: "The blendmode name",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The aligned and blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendAligned(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64),
                a[2].(string),
                a[3].(string), 
            )
        },
    )
    l.funcs.register("load", "Loads an image",
        []dslParamMeta{ 
            { 
                name: "path",
                typ:  "string", 
                def:  "-", 
                desc: "- - Path to the image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The loaded image",
            },
        },
        func(a ...any) (any, error) {
            return load(
                a[0].(string), 
            )
        },
    )
    l.funcs.register("save", "Saves an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to save",
            },
            { 
                name: "path",
                typ:  "string", 
                def:  "-", 
                desc: "- - Path where to save",
            },
        },
        []dslParamMeta{ 
        },
        func(a ...any) (any, error) {
            return save(
                a[0].(*image.NRGBA64),
                a[1].(string), 
            )
        },
    )
    l.funcs.register("add", "Adds the two numbers",
        []dslParamMeta{ 
            { 
                name: "a",
                typ:  "float64", 
                def:  "-", 
                desc: "The first number",
            },
            { 
                name: "b",
                typ:  "float64", 
                def:  "-", 
                desc: "The second number",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - a+b",
            },
        },
        func(a ...any) (any, error) {
            return add(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("add-n", "Multiplies b by n and adds the result to a",
        []dslParamMeta{ 
            { 
                name: "a",
                typ:  "float64", 
                def:  "-", 
                desc: "The first number",
            },
            { 
                name: "b",
                typ:  "float64", 
                def:  "-", 
                desc: "The second number",
            },
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The multiplier for the second number",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - a + (n * b)",
            },
        },
        func(a ...any) (any, error) {
            return addN(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("sub", "Subtracts the two numbers",
        []dslParamMeta{ 
            { 
                name: "a",
                typ:  "float64", 
                def:  "-", 
                desc: "The first number",
            },
            { 
                name: "b",
                typ:  "float64", 
                def:  "-", 
                desc: "The second number",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - a-b",
            },
        },
        func(a ...any) (any, error) {
            return sub(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("sub-n", "Multiplies b by n and subtracts the result from a",
        []dslParamMeta{ 
            { 
                name: "a",
                typ:  "float64", 
                def:  "-", 
                desc: "The first number",
            },
            { 
                name: "b",
                typ:  "float64", 
                def:  "-", 
                desc: "The second number",
            },
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The multiplier for the second number",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - a - (n * b)",
            },
        },
        func(a ...any) (any, error) {
            return subN(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("mul", "Multiplies the two numbers",
        []dslParamMeta{ 
            { 
                name: "a",
                typ:  "float64", 
                def:  "-", 
                desc: "The first number",
            },
            { 
                name: "b",
                typ:  "float64", 
                def:  "-", 
                desc: "The second number",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - a*b",
            },
        },
        func(a ...any) (any, error) {
            return mul(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("div", "Divides the two numbers",
        []dslParamMeta{ 
            { 
                name: "a",
                typ:  "float64", 
                def:  "-", 
                desc: "The first number",
            },
            { 
                name: "b",
                typ:  "float64", 
                def:  "-", 
                desc: "The second number",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - a/b",
            },
        },
        func(a ...any) (any, error) {
            return div(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("fibonacci", "Calculates the nth fibonacci number using 1-based indexing with memoization",
        []dslParamMeta{ 
            { 
                name: "nth",
                typ:  "float64", 
                def:  "-", 
                desc: "The nth fibonacci number to calculate",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The nth fibonacci number",
            },
        },
        func(a ...any) (any, error) {
            return fibonacci(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("floor", "Returns the largest integer less than or equal to x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The largest integer less than or equal to x",
            },
        },
        func(a ...any) (any, error) {
            return floor(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("ceil", "Returns the smallest integer greater than or equal to x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The smallest integer greater than or equal to x",
            },
        },
        func(a ...any) (any, error) {
            return ceil(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("round", "Returns the nearest integer to x, rounding to even on ties",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The nearest integer to x",
            },
        },
        func(a ...any) (any, error) {
            return round(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("min", "Returns the minimum value of x and y",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The x value",
            },
            { 
                name: "y",
                typ:  "float64", 
                def:  "-", 
                desc: "The y value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The minimum value of x and y",
            },
        },
        func(a ...any) (any, error) {
            return min(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("max", "Returns the maximum value of x and y",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The x value",
            },
            { 
                name: "y",
                typ:  "float64", 
                def:  "-", 
                desc: "The y value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The maximum value of x and y",
            },
        },
        func(a ...any) (any, error) {
            return max(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("delta", "Returns the delta between x and y",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The x value",
            },
            { 
                name: "y",
                typ:  "float64", 
                def:  "-", 
                desc: "The y value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The delta between x and y",
            },
        },
        func(a ...any) (any, error) {
            return delta(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("abs", "Returns the absolute value of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The absolute value of x",
            },
        },
        func(a ...any) (any, error) {
            return abs(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("slope", "Calculates the slope between two points",
        []dslParamMeta{ 
            { 
                name: "x1",
                typ:  "float64", 
                def:  "-", 
                desc: "The x coordinate of the first point",
            },
            { 
                name: "y1",
                typ:  "float64", 
                def:  "-", 
                desc: "The y coordinate of the first point",
            },
            { 
                name: "x2",
                typ:  "float64", 
                def:  "-", 
                desc: "The x coordinate of the second point",
            },
            { 
                name: "y2",
                typ:  "float64", 
                def:  "-", 
                desc: "The y coordinate of the second point",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The slope value",
            },
        },
        func(a ...any) (any, error) {
            return slope(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("tan-of-slope", "Calculates the angle from a slope value",
        []dslParamMeta{ 
            { 
                name: "m",
                typ:  "float64", 
                def:  "-", 
                desc: "The slope value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The angle in radians",
            },
        },
        func(a ...any) (any, error) {
            return tanOfSlope(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("hypotenuse-of-triangle", "Calculates hypotenuse from adjacent, opposite and gamma angle",
        []dslParamMeta{ 
            { 
                name: "adjacent",
                typ:  "float64", 
                def:  "-", 
                desc: "The adjacent side length",
            },
            { 
                name: "opposite",
                typ:  "float64", 
                def:  "-", 
                desc: "The opposite side length",
            },
            { 
                name: "gamma",
                typ:  "float64", 
                def:  "-", 
                desc: "The gamma angle",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The hypotenuse length",
            },
        },
        func(a ...any) (any, error) {
            return hypotenuseOfTriangle(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("adjacent-of-triangle", "Calculates adjacent side from hypotenuse, opposite and alpha angle",
        []dslParamMeta{ 
            { 
                name: "hypotenuse",
                typ:  "float64", 
                def:  "-", 
                desc: "The hypotenuse length",
            },
            { 
                name: "opposite",
                typ:  "float64", 
                def:  "-", 
                desc: "The opposite side length",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                def:  "-", 
                desc: "The alpha angle",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The adjacent side length",
            },
        },
        func(a ...any) (any, error) {
            return adjacentOfTriangle(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("opposite-of-triangle", "Calculates opposite side from hypotenuse, adjacent and beta angle",
        []dslParamMeta{ 
            { 
                name: "hypotenuse",
                typ:  "float64", 
                def:  "-", 
                desc: "The hypotenuse length",
            },
            { 
                name: "adjacent",
                typ:  "float64", 
                def:  "-", 
                desc: "The adjacent side length",
            },
            { 
                name: "beta",
                typ:  "float64", 
                def:  "-", 
                desc: "The beta angle",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The opposite side length",
            },
        },
        func(a ...any) (any, error) {
            return oppositeOfTriangle(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("circumference-of-a_circle", "Calculates circumference from radius",
        []dslParamMeta{ 
            { 
                name: "radius",
                typ:  "float64", 
                def:  "-", 
                desc: "The radius of the circle",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The circumference length",
            },
        },
        func(a ...any) (any, error) {
            return circumferenceOfACircle(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("distance-between", "Calculates distance between two points",
        []dslParamMeta{ 
            { 
                name: "x1",
                typ:  "float64", 
                def:  "-", 
                desc: "The x coordinate of the first point",
            },
            { 
                name: "y1",
                typ:  "float64", 
                def:  "-", 
                desc: "The y coordinate of the first point",
            },
            { 
                name: "x2",
                typ:  "float64", 
                def:  "-", 
                desc: "The x coordinate of the second point",
            },
            { 
                name: "y2",
                typ:  "float64", 
                def:  "-", 
                desc: "The y coordinate of the second point",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The distance between the points",
            },
        },
        func(a ...any) (any, error) {
            return distanceBetween(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("angle-between", "Calculates angle between two points",
        []dslParamMeta{ 
            { 
                name: "x1",
                typ:  "float64", 
                def:  "-", 
                desc: "The x coordinate of the first point",
            },
            { 
                name: "y1",
                typ:  "float64", 
                def:  "-", 
                desc: "The y coordinate of the first point",
            },
            { 
                name: "x2",
                typ:  "float64", 
                def:  "-", 
                desc: "The x coordinate of the second point",
            },
            { 
                name: "y2",
                typ:  "float64", 
                def:  "-", 
                desc: "The y coordinate of the second point",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The angle in radians",
            },
        },
        func(a ...any) (any, error) {
            return angleBetween(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("square", "Calculates the square of a number",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The square of x",
            },
        },
        func(a ...any) (any, error) {
            return square(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("pow", "Calculates base raised to the power of n, using lookup tables for integer bases when possible",
        []dslParamMeta{ 
            { 
                name: "base",
                typ:  "float64", 
                def:  "-", 
                desc: "The base value",
            },
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The exponent",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - Base^n",
            },
        },
        func(a ...any) (any, error) {
            return pow(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("pow2", "Calculates 2 raised to the power of n",
        []dslParamMeta{ 
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The exponent",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - 2^n",
            },
        },
        func(a ...any) (any, error) {
            return pow2(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("pow4", "Calculates 4 raised to the power of n",
        []dslParamMeta{ 
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The exponent",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - 4^n",
            },
        },
        func(a ...any) (any, error) {
            return pow4(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("pow8", "Calculates 8 raised to the power of n",
        []dslParamMeta{ 
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The exponent",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - 8^n",
            },
        },
        func(a ...any) (any, error) {
            return pow8(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("pow10", "Calculates 10 raised to the power of n",
        []dslParamMeta{ 
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The exponent",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - 10^n",
            },
        },
        func(a ...any) (any, error) {
            return pow10(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("pow12", "Calculates 12 raised to the power of n",
        []dslParamMeta{ 
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The exponent",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - 12^n",
            },
        },
        func(a ...any) (any, error) {
            return pow12(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("pow16", "Calculates 16 raised to the power of n",
        []dslParamMeta{ 
            { 
                name: "n",
                typ:  "float64", 
                def:  "-", 
                desc: "The exponent",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - 16^n",
            },
        },
        func(a ...any) (any, error) {
            return pow16(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("sqrt", "Returns the square root of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The square root of x",
            },
        },
        func(a ...any) (any, error) {
            return sqrt(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("log", "Returns the natural logarithm of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The natural logarithm of x",
            },
        },
        func(a ...any) (any, error) {
            return logX(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("random-range", "Returns a random number between min and max",
        []dslParamMeta{ 
            { 
                name: "min",
                typ:  "float64", 
                def:  "-", 
                desc: "The minimum value",
            },
            { 
                name: "max",
                typ:  "float64", 
                def:  "-", 
                desc: "The maximum value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A random float64 value between min and max, with NaN handling",
            },
        },
        func(a ...any) (any, error) {
            return randomRange(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("or", "Returns either value1 or value2 randomly",
        []dslParamMeta{ 
            { 
                name: "value1",
                typ:  "float64", 
                def:  "-", 
                desc: "The first value",
            },
            { 
                name: "value2",
                typ:  "float64", 
                def:  "-", 
                desc: "The second value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - One of the two input values randomly",
            },
        },
        func(a ...any) (any, error) {
            return randomOr(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("degrees2radians", "converts degrees to radians",
        []dslParamMeta{ 
            { 
                name: "degrees",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in degrees",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - angle in radians",
            },
        },
        func(a ...any) (any, error) {
            return degrees2Radians(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("grads2radians", "converts grads to radians",
        []dslParamMeta{ 
            { 
                name: "grads",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in grads",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - angle in radians",
            },
        },
        func(a ...any) (any, error) {
            return grads2Radians(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("radians2degrees", "converts radians to degrees",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - angle in degrees",
            },
        },
        func(a ...any) (any, error) {
            return radians2Degrees(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("radians2grads", "converts radians to grads",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - angle in grads",
            },
        },
        func(a ...any) (any, error) {
            return radians2Grads(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("normalize-angle", "normalizes an angle to [0, 2)",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - normalized angle in radians",
            },
        },
        func(a ...any) (any, error) {
            return normalizeAngle(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("normalize-angle-degrees", "normalizes an angle to [0, 360)",
        []dslParamMeta{ 
            { 
                name: "degrees",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in degrees",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - normalized angle in degrees",
            },
        },
        func(a ...any) (any, error) {
            return normalizeAngleDegrees(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("angle-difference", "calculates the smallest difference between two angles",
        []dslParamMeta{ 
            { 
                name: "angle1",
                typ:  "float64", 
                def:  "-", 
                desc: "The first angle in radians",
            },
            { 
                name: "angle2",
                typ:  "float64", 
                def:  "-", 
                desc: "The second angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - smallest angle difference in radians",
            },
        },
        func(a ...any) (any, error) {
            return angleDifference(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("angle-difference-degrees", "calculates the smallest difference between two angles in degrees",
        []dslParamMeta{ 
            { 
                name: "angle1",
                typ:  "float64", 
                def:  "-", 
                desc: "The first angle in degrees",
            },
            { 
                name: "angle2",
                typ:  "float64", 
                def:  "-", 
                desc: "The second angle in degrees",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - smallest angle difference in degrees",
            },
        },
        func(a ...any) (any, error) {
            return angleDifferenceDegrees(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("sin", "calculates the sine of an angle",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - sine value between -1 and 1",
            },
        },
        func(a ...any) (any, error) {
            return sin(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("asin", "calculates the arcsine (inverse sine) of x",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - angle in radians between -PI/2 and PI/2",
            },
        },
        func(a ...any) (any, error) {
            return asin(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("cos", "calculates the cosine of an angle in radians",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - cosine value between -1 and 1",
            },
        },
        func(a ...any) (any, error) {
            return cos(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("acos", "calculates the arccosine (inverse cosine) of x",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - angle in radians between 0 and PI",
            },
        },
        func(a ...any) (any, error) {
            return acos(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("tan", "calculates the tangent of an angle in radians",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - tangent value (unbounded)",
            },
        },
        func(a ...any) (any, error) {
            return tan(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("atan", "calculates the arctangent (inverse tangent) of x",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - angle in radians between -PI/2 and PI/2",
            },
        },
        func(a ...any) (any, error) {
            return atan(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("sec", "calculates the secant of an angle in radians",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - secant value (1/cos)",
            },
        },
        func(a ...any) (any, error) {
            return sec(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("cosec", "calculates the cosecant of an angle in radians",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - cosecant value (1/sin)",
            },
        },
        func(a ...any) (any, error) {
            return cosec(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("cot", "calculates the cotangent of an angle in radians",
        []dslParamMeta{ 
            { 
                name: "radians",
                typ:  "float64", 
                def:  "-", 
                desc: "The angle in radians",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - cotangent value (1/tan)",
            },
        },
        func(a ...any) (any, error) {
            return cot(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("sinh", "calculates the hyperbolic sine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - hyperbolic sine value",
            },
        },
        func(a ...any) (any, error) {
            return sinh(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("cosh", "calculates the hyperbolic cosine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - hyperbolic cosine value (always positive)",
            },
        },
        func(a ...any) (any, error) {
            return cosh(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("tanh", "calculates the hyperbolic tangent of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - hyperbolic tangent value between -1 and 1",
            },
        },
        func(a ...any) (any, error) {
            return tanh(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("sech", "calculates the hyperbolic secant of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - hyperbolic secant value (1/cosh)",
            },
        },
        func(a ...any) (any, error) {
            return sech(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("csch", "calculates the hyperbolic cosecant of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - hyperbolic cosecant value (1/sinh)",
            },
        },
        func(a ...any) (any, error) {
            return csch(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("coth", "calculates the hyperbolic cotangent of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - hyperbolic cotangent value (1/tanh)",
            },
        },
        func(a ...any) (any, error) {
            return coth(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("asinh", "calculates the inverse hyperbolic sine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - inverse hyperbolic sine value",
            },
        },
        func(a ...any) (any, error) {
            return asinh(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("acosh", "calculates the inverse hyperbolic cosine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - inverse hyperbolic cosine value (x >= 1)",
            },
        },
        func(a ...any) (any, error) {
            return acosh(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("atanh", "calculates the inverse hyperbolic tangent of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - inverse hyperbolic tangent value (|x| < 1)",
            },
        },
        func(a ...any) (any, error) {
            return atanh(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("asech", "calculates the inverse hyperbolic secant of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - inverse hyperbolic secant value (0 < x <= 1)",
            },
        },
        func(a ...any) (any, error) {
            return asech(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("acsch", "calculates the inverse hyperbolic cosecant of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - inverse hyperbolic cosecant value (x != 0)",
            },
        },
        func(a ...any) (any, error) {
            return acsch(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("acoth", "calculates the inverse hyperbolic cotangent of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - inverse hyperbolic cotangent value (|x| > 1)",
            },
        },
        func(a ...any) (any, error) {
            return acoth(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("versin", "calculates the versed sine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - versed sine value (1 - cos(x))",
            },
        },
        func(a ...any) (any, error) {
            return versin(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("vercos", "calculates the versed cosine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - versed cosine value (1 + cos(x))",
            },
        },
        func(a ...any) (any, error) {
            return vercos(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("coversin", "calculates the coversed sine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - coversed sine value (1 - sin(x))",
            },
        },
        func(a ...any) (any, error) {
            return coversin(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("covercos", "calculates the coversed cosine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - coversed cosine value (1 + sin(x))",
            },
        },
        func(a ...any) (any, error) {
            return covercos(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("haversin", "calculates the haversine of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - haversine value (0.5 * (1 - cos(x)))",
            },
        },
        func(a ...any) (any, error) {
            return haversin(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("exsec", "calculates the exsecant of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - exsecant value (sec(x) - 1)",
            },
        },
        func(a ...any) (any, error) {
            return exsec(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("excsc", "calculates the excosecant of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - excosecant value (cosec(x) - 1)",
            },
        },
        func(a ...any) (any, error) {
            return excsc(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("chord", "calculates the chord of x",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - chord value (2 * sin(x/2))",
            },
        },
        func(a ...any) (any, error) {
            return chord(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("sin-of-triangle", "calculates sine using opposite and hypotenuse sides",
        []dslParamMeta{ 
            { 
                name: "opposite",
                typ:  "float64", 
                def:  "-", 
                desc: "The opposite side length",
            },
            { 
                name: "hypotenuse",
                typ:  "float64", 
                def:  "-", 
                desc: "The hypotenuse length",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - sine value (opposite/hypotenuse)",
            },
        },
        func(a ...any) (any, error) {
            return sinOfTriangle(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("cos-of-triangle", "calculates cosine using adjacent and hypotenuse sides",
        []dslParamMeta{ 
            { 
                name: "adjacent",
                typ:  "float64", 
                def:  "-", 
                desc: "The adjacent side length",
            },
            { 
                name: "hypotenuse",
                typ:  "float64", 
                def:  "-", 
                desc: "The hypotenuse length",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - cosine value (adjacent/hypotenuse)",
            },
        },
        func(a ...any) (any, error) {
            return cosOfTriangle(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("tan-of-triangle", "calculates tangent using opposite and adjacent sides",
        []dslParamMeta{ 
            { 
                name: "opposite",
                typ:  "float64", 
                def:  "-", 
                desc: "The opposite side length",
            },
            { 
                name: "adjacent",
                typ:  "float64", 
                def:  "-", 
                desc: "The adjacent side length",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - tangent value (opposite/adjacent)",
            },
        },
        func(a ...any) (any, error) {
            return tanOfTriangle(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("sec-of-triangle", "calculates secant using hypotenuse and adjacent sides",
        []dslParamMeta{ 
            { 
                name: "hypotenuse",
                typ:  "float64", 
                def:  "-", 
                desc: "The hypotenuse length",
            },
            { 
                name: "adjacent",
                typ:  "float64", 
                def:  "-", 
                desc: "The adjacent side length",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - secant value (hypotenuse/adjacent)",
            },
        },
        func(a ...any) (any, error) {
            return secOfTriangle(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("cosec-of-triangle", "calculates cosecant using hypotenuse and opposite sides",
        []dslParamMeta{ 
            { 
                name: "hypotenuse",
                typ:  "float64", 
                def:  "-", 
                desc: "The hypotenuse length",
            },
            { 
                name: "opposite",
                typ:  "float64", 
                def:  "-", 
                desc: "The opposite side length",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - cosecant value (hypotenuse/opposite)",
            },
        },
        func(a ...any) (any, error) {
            return cosecOfTriangle(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("cot-of-triangle", "calculates cotangent using adjacent and opposite sides",
        []dslParamMeta{ 
            { 
                name: "adjacent",
                typ:  "float64", 
                def:  "-", 
                desc: "The adjacent side length",
            },
            { 
                name: "opposite",
                typ:  "float64", 
                def:  "-", 
                desc: "The opposite side length",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - cotangent value (adjacent/opposite)",
            },
        },
        func(a ...any) (any, error) {
            return cotOfTriangle(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("radians-of-triangle", "calculates angle in radians using all three sides of a triangle",
        []dslParamMeta{ 
            { 
                name: "adjacent",
                typ:  "float64", 
                def:  "-", 
                desc: "The adjacent side length",
            },
            { 
                name: "opposite",
                typ:  "float64", 
                def:  "-", 
                desc: "The opposite side length",
            },
            { 
                name: "hypotenuse",
                typ:  "float64", 
                def:  "-", 
                desc: "The hypotenuse length",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - angle in radians between adjacent and opposite sides",
            },
        },
        func(a ...any) (any, error) {
            return radiansOfTriangle(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("sin2", "calculates the square of sine (sin짼(x))",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - squared sine value (sin(x)짼)",
            },
        },
        func(a ...any) (any, error) {
            return sin2(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("cos2", "calculates the square of cosine (cos짼(x))",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - squared cosine value (cos(x)짼)",
            },
        },
        func(a ...any) (any, error) {
            return cos2(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("tan2", "calculates the square of tangent (tan짼(x))",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - squared tangent value (tan(x)짼)",
            },
        },
        func(a ...any) (any, error) {
            return tan2(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("sinc", "calculates the sinc function (sin(x)/x)",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The input value",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - sinc value (sin(x)/x, with sinc(0) = 1)",
            },
        },
        func(a ...any) (any, error) {
            return sinc(
                a[0].(float64), 
            )
        },
    )
    l.funcs.register("lerp-angle", "linearly interpolates between two angles in radians",
        []dslParamMeta{ 
            { 
                name: "angle1",
                typ:  "float64", 
                def:  "-", 
                desc: "The first angle in radians",
            },
            { 
                name: "angle2",
                typ:  "float64", 
                def:  "-", 
                desc: "The second angle in radians",
            },
            { 
                name: "t",
                typ:  "float64", 
                def:  "-", 
                desc: "The interpolation factor (0-1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - interpolated angle in radians",
            },
        },
        func(a ...any) (any, error) {
            return lerpAngle(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("lerp-angle-degrees", "linearly interpolates between two angles in degrees",
        []dslParamMeta{ 
            { 
                name: "angle1",
                typ:  "float64", 
                def:  "-", 
                desc: "The first angle in degrees",
            },
            { 
                name: "angle2",
                typ:  "float64", 
                def:  "-", 
                desc: "The second angle in degrees",
            },
            { 
                name: "t",
                typ:  "float64", 
                def:  "-", 
                desc: "The interpolation factor (0-1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - interpolated angle in degrees",
            },
        },
        func(a ...any) (any, error) {
            return lerpAngleDegrees(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("len", "Returns the length of the given value.",
        []dslParamMeta{ 
            { 
                name: "v",
                typ:  "any", 
                def:  "-", 
                desc: "The value to get the length of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The length of v",
            },
        },
        func(a ...any) (any, error) {
            return len2(
                a[0].(any), 
            )
        },
    )
    l.funcs.register("plot-data", "Renders a chart from CSV data by plotting selected columns with specified colors",
        []dslParamMeta{ 
            { 
                name: "width",
                typ:  "int", 
                def:  "-", 
                desc: "Chart width in pixels",
            },
            { 
                name: "height",
                typ:  "int", 
                def:  "-", 
                desc: "Chart height in pixels",
            },
            { 
                name: "data",
                typ:  "[][]float64", 
                def:  "-", 
                desc: "2D array of data from CSV",
            },
            { 
                name: "columns",
                typ:  "[]any", 
                def:  "-", 
                desc: "Array of column indices to plot",
            },
            { 
                name: "colors",
                typ:  "[]any", 
                def:  "-", 
                desc: "Array of colors for each column",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The chart image",
            },
        },
        func(a ...any) (any, error) {
            return plotData(
                a[0].(int),
                a[1].(int),
                a[2].([][]float64),
                a[3].([]any),
                a[4].([]any), 
            )
        },
    )
    l.funcs.register("plot-data-compact", "Renders a chart from CSV data by plotting selected columns with specified colors. The series will be normalized to 0..1 based on their minium and maximimum value.",
        []dslParamMeta{ 
            { 
                name: "width",
                typ:  "int", 
                def:  "-", 
                desc: "Chart width in pixels",
            },
            { 
                name: "height",
                typ:  "int", 
                def:  "-", 
                desc: "Chart height in pixels",
            },
            { 
                name: "data",
                typ:  "[][]float64", 
                def:  "-", 
                desc: "2D array of data from CSV",
            },
            { 
                name: "columns",
                typ:  "[]any", 
                def:  "-", 
                desc: "Array of column indices to plot",
            },
            { 
                name: "colors",
                typ:  "[]any", 
                def:  "-", 
                desc: "Array of colors for each column",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The chart image",
            },
        },
        func(a ...any) (any, error) {
            return plotDataCompact(
                a[0].(int),
                a[1].(int),
                a[2].([][]float64),
                a[3].([]any),
                a[4].([]any), 
            )
        },
    )
    l.funcs.register("plot-series", "Renders a series from CSV data by plotting a single column with colors determined by value using color stops",
        []dslParamMeta{ 
            { 
                name: "width",
                typ:  "int", 
                def:  "-", 
                desc: "Chart width in pixels",
            },
            { 
                name: "height",
                typ:  "int", 
                def:  "-", 
                desc: "Chart height in pixels",
            },
            { 
                name: "data",
                typ:  "[][]float64", 
                def:  "-", 
                desc: "2D array of data from CSV",
            },
            { 
                name: "column",
                typ:  "int", 
                def:  "-", 
                desc: "Column index to plot",
            },
            { 
                name: "min",
                typ:  "float64", 
                def:  "-", 
                desc: "Minimum value for color mapping",
            },
            { 
                name: "max",
                typ:  "float64", 
                def:  "-", 
                desc: "Maximum value for color mapping",
            },
            { 
                name: "stops",
                typ:  "[][]any", 
                def:  "-", 
                desc: "Color stops as [][]any where each stop is [threshold, hue, saturation, lightness, alpha]; additional fields are ignored",
            },
            { 
                name: "invertY",
                typ:  "bool", 
                def:  false, 
                desc: "Whether flip the y-axis when plotting",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The chart image",
            },
        },
        func(a ...any) (any, error) {
            return plotSeries(
                a[0].(int),
                a[1].(int),
                a[2].([][]float64),
                a[3].(int),
                a[4].(float64),
                a[5].(float64),
                a[6].([][]any),
                a[7].(bool), 
            )
        },
    )
    l.funcs.register("printf", "Prints formatted strings to the console",
        []dslParamMeta{ 
            { 
                name: "str",
                typ:  "string", 
                def:  "-", 
                desc: "- - The format string",
            },
            { 
                name: "a",
                typ:  "[]any", 
                def:  "-", 
                desc: "A slice with the arguments",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - Number of bytes written",
            },
        },
        func(a ...any) (any, error) {
            return printf(
                a[0].(string),
                a[1].([]any), 
            )
        },
    )
    l.funcs.register("printfln", "Prints formatted strings to the console",
        []dslParamMeta{ 
            { 
                name: "str",
                typ:  "string", 
                def:  "-", 
                desc: "- - The format string",
            },
            { 
                name: "a",
                typ:  "[]any", 
                def:  "-", 
                desc: "A slice with the arguments",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - Number of bytes written",
            },
        },
        func(a ...any) (any, error) {
            return printfln(
                a[0].(string),
                a[1].([]any), 
            )
        },
    )
    l.funcs.register("sprintf", "Creates formatted strings",
        []dslParamMeta{ 
            { 
                name: "str",
                typ:  "string", 
                def:  "-", 
                desc: "- - The format string",
            },
            { 
                name: "a",
                typ:  "[]any", 
                def:  "-", 
                desc: "A slice with the arguments",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The formatted string",
            },
        },
        func(a ...any) (any, error) {
            return sprintf(
                a[0].(string),
                a[1].([]any), 
            )
        },
    )
    l.funcs.register("uppercase", "Uppercases a string",
        []dslParamMeta{ 
            { 
                name: "str",
                typ:  "string", 
                def:  "-", 
                desc: "- - The string to uppercase",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The uppercased string",
            },
        },
        func(a ...any) (any, error) {
            return uppercase(
                a[0].(string), 
            )
        },
    )
    l.funcs.register("lowercase", "Lowercases a string",
        []dslParamMeta{ 
            { 
                name: "str",
                typ:  "string", 
                def:  "-", 
                desc: "- - The string to lowercase",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The lowercased string",
            },
        },
        func(a ...any) (any, error) {
            return lowercase(
                a[0].(string), 
            )
        },
    )
    l.funcs.register("now", "Returns the current time according to the given layout",
        []dslParamMeta{ 
            { 
                name: "offset",
                typ:  "int", 
                def:  0, 
                desc: "The amount of seconds to offset the current time by",
            },
            { 
                name: "layout",
                typ:  "string", 
                def:  "2006-01-02 15:04:05", 
                desc: "The layout",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The current time as string",
            },
        },
        func(a ...any) (any, error) {
            return nowStr(
                a[0].(int),
                a[1].(string), 
            )
        },
    )
    l.funcs.register("P", "Creates a new point at P(x|y).",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  0, 
                desc: "The start position on the x-axis",
            },
            { 
                name: "y",
                typ:  "float64", 
                def:  0, 
                desc: "The start position on the y-axis",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A new point",
            },
        },
        func(a ...any) (any, error) {
            return makePoint(
                a[0].(float64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("Px", "Returns the x-coordinate of a point.",
        []dslParamMeta{ 
            { 
                name: "p",
                typ:  "Point", 
                def:  "-", 
                desc: "The point to return the x-coordinate of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The x-coordinate of p",
            },
        },
        func(a ...any) (any, error) {
            return pointX(
                a[0].(Point), 
            )
        },
    )
    l.funcs.register("Py", "Returns the y-coordinate of a point.",
        []dslParamMeta{ 
            { 
                name: "p",
                typ:  "Point", 
                def:  "-", 
                desc: "The point to return the y-coordinate of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The y-coordinate of p",
            },
        },
        func(a ...any) (any, error) {
            return pointY(
                a[0].(Point), 
            )
        },
    )
    l.funcs.register("V", "Creates a new Vector from x, y and z.",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  0, 
                desc: "The x-component",
            },
            { 
                name: "y",
                typ:  "float64", 
                def:  0, 
                desc: "The y-component",
            },
            { 
                name: "z",
                typ:  "float64", 
                def:  0, 
                desc: "The z-component",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A new vector",
            },
        },
        func(a ...any) (any, error) {
            return makeVector(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("Vx", "Returns the x-component of a vector.",
        []dslParamMeta{ 
            { 
                name: "v",
                typ:  "Vector", 
                def:  "-", 
                desc: "The vector to return the x-component of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The x-component of v",
            },
        },
        func(a ...any) (any, error) {
            return vectorX(
                a[0].(Vector), 
            )
        },
    )
    l.funcs.register("Vy", "Returns the y-component of a vector.",
        []dslParamMeta{ 
            { 
                name: "v",
                typ:  "Vector", 
                def:  "-", 
                desc: "The vector to return the y-component of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The y-component of vp",
            },
        },
        func(a ...any) (any, error) {
            return vectorY(
                a[0].(Vector), 
            )
        },
    )
    l.funcs.register("Vz", "Returns the z-component of a vector.",
        []dslParamMeta{ 
            { 
                name: "v",
                typ:  "Vector", 
                def:  "-", 
                desc: "The vector to return the z-component of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The z-component of vp",
            },
        },
        func(a ...any) (any, error) {
            return vectorZ(
                a[0].(Vector), 
            )
        },
    )
    l.funcs.register("R", "Creates a new rectangle with the given dimensions at P(x|y).",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                def:  "-", 
                desc: "The upper-left corner of the rectangle",
            },
            { 
                name: "y",
                typ:  "float64", 
                def:  "-", 
                desc: "The upper-left corner of the rectangle",
            },
            { 
                name: "w",
                typ:  "float64", 
                def:  "-", 
                desc: "The width of the rectangle",
            },
            { 
                name: "h",
                typ:  "float64", 
                def:  "-", 
                desc: "The width of the rectangle",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A new rectangle",
            },
        },
        func(a ...any) (any, error) {
            return makeRect(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("Rx", "Returns the x-coordinate of a rect.",
        []dslParamMeta{ 
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The rect to return the x-coordinate of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The x-coordinate of r",
            },
        },
        func(a ...any) (any, error) {
            return rectX(
                a[0].(Rect), 
            )
        },
    )
    l.funcs.register("Ry", "Returns the y-coordinate of a rect.",
        []dslParamMeta{ 
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The rect to return the y-coordinate of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The y-coordinate of r",
            },
        },
        func(a ...any) (any, error) {
            return rectY(
                a[0].(Rect), 
            )
        },
    )
    l.funcs.register("Rw", "Returns the width of a rect.",
        []dslParamMeta{ 
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The rect to return the width of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The width of r",
            },
        },
        func(a ...any) (any, error) {
            return rectW(
                a[0].(Rect), 
            )
        },
    )
    l.funcs.register("Rh", "Returns the height of a rect.",
        []dslParamMeta{ 
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The rect to return the height of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The height of r",
            },
        },
        func(a ...any) (any, error) {
            return rectH(
                a[0].(Rect), 
            )
        },
    )
    l.funcs.register("E", "Creates a new ellipse with the given radius at P(x|y).",
        []dslParamMeta{ 
            { 
                name: "centerX",
                typ:  "float64", 
                def:  "-", 
                desc: "The center of the ellipse on the x-axis",
            },
            { 
                name: "centerY",
                typ:  "float64", 
                def:  "-", 
                desc: "The center of the ellipse on the y-axis",
            },
            { 
                name: "radiusX",
                typ:  "float64", 
                def:  "-", 
                desc: "The radius of the ellipse on the x-axis",
            },
            { 
                name: "radiusY",
                typ:  "float64", 
                def:  "-", 
                desc: "The radius of the ellipse on the y-axis",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A new ellipse",
            },
        },
        func(a ...any) (any, error) {
            return makeEllipse(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    l.funcs.register("Ex", "Returns the center x-coordinate of an ellipse.",
        []dslParamMeta{ 
            { 
                name: "e",
                typ:  "Ellipse", 
                def:  "-", 
                desc: "The ellipse to return the center x-coordinate of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - the center x-coordinate of e",
            },
        },
        func(a ...any) (any, error) {
            return ellipseX(
                a[0].(Ellipse), 
            )
        },
    )
    l.funcs.register("Ey", "Returns the center y-coordinate of an ellipse.",
        []dslParamMeta{ 
            { 
                name: "e",
                typ:  "Ellipse", 
                def:  "-", 
                desc: "The ellipse to return the center y-coordinate of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - the center y-coordinate of e",
            },
        },
        func(a ...any) (any, error) {
            return ellipseY(
                a[0].(Ellipse), 
            )
        },
    )
    l.funcs.register("Erx", "Returns the x-component of the radius of an ellipse.",
        []dslParamMeta{ 
            { 
                name: "e",
                typ:  "Ellipse", 
                def:  "-", 
                desc: "The ellipse to return the x-component of the radius of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - the x-component of the radius of e",
            },
        },
        func(a ...any) (any, error) {
            return ellipseRadiusX(
                a[0].(Ellipse), 
            )
        },
    )
    l.funcs.register("Ery", "Returns the y-component of the radius of an ellipse.",
        []dslParamMeta{ 
            { 
                name: "e",
                typ:  "Ellipse", 
                def:  "-", 
                desc: "The ellipse to return the y-component of the radius of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - the y-component of the radius of e",
            },
        },
        func(a ...any) (any, error) {
            return ellipseRadiusY(
                a[0].(Ellipse), 
            )
        },
    )
    l.funcs.register("C", "Creates a new circle with the given radius at P(x|y).",
        []dslParamMeta{ 
            { 
                name: "centerX",
                typ:  "float64", 
                def:  "-", 
                desc: "The center of the circle on the x-axis",
            },
            { 
                name: "centerY",
                typ:  "float64", 
                def:  "-", 
                desc: "The center of the circle on the y-axis",
            },
            { 
                name: "radius",
                typ:  "float64", 
                def:  "-", 
                desc: "The radius of the circle",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A new circle",
            },
        },
        func(a ...any) (any, error) {
            return makeCircle(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    l.funcs.register("Iw", "Returns the width of an image.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to return the width of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The width of img",
            },
        },
        func(a ...any) (any, error) {
            return imageW(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("Ih", "Returns the height of an image.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to return the height of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The height of img",
            },
        },
        func(a ...any) (any, error) {
            return imageH(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("Ir", "Returns the aspect ratio of the given image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to return the aspect ratio of",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - Aspect ratio of the image",
            },
        },
        func(a ...any) (any, error) {
            return imageAspectRatio(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    l.funcs.register("IC", "Creates a new image with the given color.",
        []dslParamMeta{ 
            { 
                name: "w",
                typ:  "int", 
                def:  "-", 
                desc: "The width of the image",
            },
            { 
                name: "h",
                typ:  "int", 
                def:  "-", 
                desc: "The height of the image",
            },
            { 
                name: "cFill",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The fill color",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The new image",
            },
        },
        func(a ...any) (any, error) {
            return makeImage(
                a[0].(int),
                a[1].(int),
                a[2].(color.RGBA64), 
            )
        },
    )
    l.funcs.register("I", "Creates a new transparent image.",
        []dslParamMeta{ 
            { 
                name: "w",
                typ:  "int", 
                def:  "-", 
                desc: "The width of the image",
            },
            { 
                name: "h",
                typ:  "int", 
                def:  "-", 
                desc: "The height of the image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The new image",
            },
        },
        func(a ...any) (any, error) {
            return makeImageTransparent(
                a[0].(int),
                a[1].(int), 
            )
        },
    )
    l.funcs.register("SI", "Copies an area from a source image and returns it as a new image.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The source image",
            },
            { 
                name: "r",
                typ:  "Rect", 
                def:  "-", 
                desc: "The selection to copy",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - The new image",
            },
        },
        func(a ...any) (any, error) {
            return extractSubImage(
                a[0].(*image.NRGBA64),
                a[1].(Rect), 
            )
        },
    )
    l.funcs.register("LS", "Creates a new line style.",
        []dslParamMeta{ 
            { 
                name: "color",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The line color",
            },
            { 
                name: "thickness",
                typ:  "float64", 
                def:  1, 
                unit: "1", 
                desc: "The line thickness",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A new line style",
            },
        },
        func(a ...any) (any, error) {
            return makeLineStyle(
                a[0].(color.RGBA64),
                a[1].(float64), 
            )
        },
    )
    l.funcs.register("FS", "Creates a new fill style.",
        []dslParamMeta{ 
            { 
                name: "color",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The fill color",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "error", 
                desc: "- - - A new fill style",
            },
        },
        func(a ...any) (any, error) {
            return makeFillStyle(
                a[0].(color.RGBA64), 
            )
        },
    )
    l.funcs.storeState() // Store the state of functions, so we can reset the language without losing them

    return l
}

func init() {
    dsl = *NewLanguage()
} 