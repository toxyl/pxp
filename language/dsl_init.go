// DO NOT EDIT THIS FILE
// This file is automatically generated by go-dsl.
// Rerun go-dsl to update the language.
// Warning: Files prefixed with `dsl_` or `template_` will be removed,
// any manual changes will be lost.

package language

import (
    "image"
    "image/color"
)

func init() {
    // First we need to initialize our language
    // so it becomes available in our pseudo-namespace.
    dsl.initDSL(
        "pxp", 
        "PixelPipeline Script", 
        "A scripting language for defining image processing pipelines.",
        "1.0.0", 
        "pxp", 
        dsl.defaultColorTheme(),
    )

    // By default your language can run all the functions
    // and use all the variables that have been defined below.
    //
    // If you ever need to reset the language to clear variables and functions
    // that have been added over time, you can do so by calling:
    //
    // dsl.restoreState()
    //
    // This will perform a full reset, which wipes all variables and
    // functions that have been created since the last time you called
    // dsl.vars.storeState() and dsl.funcs.storeState().
    //
    // You can also store the current state of the language by calling:
    //
    // dsl.storeState()

    // Register variables
    dsl.vars.storeState() // Store the state of variables, so we can reset the language without losing them

    // Register functions
    dsl.funcs.register("blend-normal", "Blends the two images using the normal blend mode (alpha compositing)",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendNormal(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-erase", "Erases the bottom image wherever the top image is present (destination out)",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendErase(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-multiply", "Blends the two images using the multiply blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendMultiply(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-screen", "Blends the two images using the screen blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendScreen(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-exclusion", "Blends the two images using the exclusion blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendExclusion(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-overlay", "Blends the two images using the overlay blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendOverlay(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-color-burn", "Blends the two images using the color burn blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendColorBurn(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-color-dodge", "Blends the two images using the color dodge blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendColorDodge(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-soft-light", "Blends the two images using the soft light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendSoftLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-hard-light", "Blends the two images using the hard light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendHardLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-difference", "Blends the two images using the difference blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendDifference(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-subtract", "Blends the two images using the subtract blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendSubtract(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-divide", "Blends the two images using the divide blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendDivide(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-hue", "Blends the two images using the hue blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendHue(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-saturation", "Blends the two images using the saturation blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendSaturation(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-color", "Blends the two images using the color blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendColor(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-luminosity", "Blends the two images using the luminosity blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendLuminosity(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-average", "Blends the two images using the average blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendAverage(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-negation", "Blends the two images using the negation blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendNegation(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-reflect", "Blends the two images using the reflect blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendReflect(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-glow", "Blends the two images using the glow blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendGlow(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-contrast-negate", "Blends the two images using the contrast negate blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendContrastNegate(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-vivid-light", "Blends the two images using the vivid light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendVividLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-linear-light", "Blends the two images using the linear light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendLinearLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-pin-light", "Blends the two images using the pin light blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendPinLight(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-darken", "Blends the two images using the darken blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendDarken(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-darker-color", "Blends the two images using the darker color blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendDarkerColor(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-lighten", "Blends the two images using the lighten blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendLighten(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-lighter-color", "Blends the two images using the lighter color blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendLighterColor(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("blend-hard-mix", "Blends the two images using the hard mix blend mode",
        []dslParamMeta{ 
            { 
                name: "imgA",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The bottom image",
            },
            { 
                name: "imgB",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The top image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blended image",
            },
        },
        func(a ...any) (any, error) {
            return blendHardMix(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("hsla", "Creates a color from HSLA values",
        []dslParamMeta{ 
            { 
                name: "h",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The color's hue",
            },
            { 
                name: "s",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                unit: "\"%\"", 
                desc: "The color's saturation",
            },
            { 
                name: "l",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                unit: "\"%\"", 
                desc: "The color's luminosity",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return hsla(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("rgba", "Creates a color from RGBA values (8-bit per channel)",
        []dslParamMeta{ 
            { 
                name: "r",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  0, 
                unit: "\"\"", 
                desc: "The red component",
            },
            { 
                name: "g",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  0, 
                unit: "\"\"", 
                desc: "The green component",
            },
            { 
                name: "b",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  0, 
                unit: "\"\"", 
                desc: "The blue component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The alpha component",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return rgba(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("rgba64", "Creates a color from RGBA values (16-bit per channel)",
        []dslParamMeta{ 
            { 
                name: "r",
                typ:  "float64", 
                min:  0, 
                max:  65535, 
                def:  0, 
                unit: "\"\"", 
                desc: "The red component",
            },
            { 
                name: "g",
                typ:  "float64", 
                min:  0, 
                max:  65535, 
                def:  0, 
                unit: "\"\"", 
                desc: "The green component",
            },
            { 
                name: "b",
                typ:  "float64", 
                min:  0, 
                max:  65535, 
                def:  0, 
                unit: "\"\"", 
                desc: "The blue component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The alpha component",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return rgba64(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("cmyk", "Creates a color from CMYK values",
        []dslParamMeta{ 
            { 
                name: "c",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The cyan component",
            },
            { 
                name: "m",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The magenta component",
            },
            { 
                name: "y",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The yellow component",
            },
            { 
                name: "k",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The key (black) component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The alpha component",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return cmyk(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    dsl.funcs.register("hsv", "Creates a color from HSV values",
        []dslParamMeta{ 
            { 
                name: "h",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The color's hue",
            },
            { 
                name: "s",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                unit: "\"%\"", 
                desc: "The color's saturation",
            },
            { 
                name: "v",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                unit: "\"%\"", 
                desc: "The color's value (brightness)",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return hsv(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("lab", "Creates a color from CIELAB values",
        []dslParamMeta{ 
            { 
                name: "l",
                typ:  "float64", 
                min:  0, 
                max:  100, 
                def:  50, 
                unit: "\"\"", 
                desc: "The lightness component",
            },
            { 
                name: "a",
                typ:  "float64", 
                min:  -128, 
                max:  127, 
                def:  0, 
                unit: "\"\"", 
                desc: "The green-red component",
            },
            { 
                name: "b",
                typ:  "float64", 
                min:  -128, 
                max:  127, 
                def:  0, 
                unit: "\"\"", 
                desc: "The blue-yellow component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return lab(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("hwb", "Creates a color from HWB (Hue, Whiteness, Blackness) values",
        []dslParamMeta{ 
            { 
                name: "h",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The color's hue",
            },
            { 
                name: "w",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The whiteness component",
            },
            { 
                name: "b",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"%\"", 
                desc: "The blackness component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return hwb(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("xyz", "Creates a color from CIE XYZ values",
        []dslParamMeta{ 
            { 
                name: "x",
                typ:  "float64", 
                min:  0, 
                max:  0.95047, 
                def:  0, 
                unit: "\"\"", 
                desc: "The X component (red)",
            },
            { 
                name: "y",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"\"", 
                desc: "The Y component (green)",
            },
            { 
                name: "z",
                typ:  "float64", 
                min:  0, 
                max:  1.08883, 
                def:  0, 
                unit: "\"\"", 
                desc: "The Z component (blue)",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return xyz(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("lch", "Creates a color from LCH (Lightness, Chroma, Hue) values",
        []dslParamMeta{ 
            { 
                name: "l",
                typ:  "float64", 
                min:  0, 
                max:  100, 
                def:  50, 
                unit: "\"\"", 
                desc: "The lightness component",
            },
            { 
                name: "c",
                typ:  "float64", 
                min:  0, 
                max:  128, 
                def:  0, 
                unit: "\"\"", 
                desc: "The chroma component",
            },
            { 
                name: "h",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The hue component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return lch(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("yuv", "Creates a color from YUV values",
        []dslParamMeta{ 
            { 
                name: "y",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0, 
                unit: "\"\"", 
                desc: "The luminance component",
            },
            { 
                name: "u",
                typ:  "float64", 
                min:  -0.436, 
                max:  0.436, 
                def:  0, 
                unit: "\"\"", 
                desc: "The U chrominance component",
            },
            { 
                name: "v",
                typ:  "float64", 
                min:  -0.615, 
                max:  0.615, 
                def:  0, 
                unit: "\"\"", 
                desc: "The V chrominance component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return yuv(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("ycbcr", "Creates a color from YCbCr values (digital video)",
        []dslParamMeta{ 
            { 
                name: "y",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  0, 
                unit: "\"\"", 
                desc: "The luminance component",
            },
            { 
                name: "cb",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  128, 
                unit: "\"\"", 
                desc: "The blue-difference chroma component",
            },
            { 
                name: "cr",
                typ:  "float64", 
                min:  0, 
                max:  255, 
                def:  128, 
                unit: "\"\"", 
                desc: "The red-difference chroma component",
            },
            { 
                name: "alpha",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                unit: "\"%\"", 
                desc: "The color's alpha",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color as color.RGBA64",
            },
        },
        func(a ...any) (any, error) {
            return ycbcr(
                a[0].(float64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("blur-gaussian", "Applies a Gaussian blur to the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to blur",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  1, 
                max:  10, 
                def:  1, 
                desc: "The blur radius (higher values create more blur)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blurred image",
            },
        },
        func(a ...any) (any, error) {
            return blurGaussian(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("blur-box", "Applies a box blur to an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to blur",
            },
            { 
                name: "radius",
                typ:  "int", 
                min:  1, 
                max:  10, 
                def:  1, 
                desc: "The blur radius (size of the box kernel)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blurred image",
            },
        },
        func(a ...any) (any, error) {
            return blurBox(
                a[0].(*image.NRGBA64),
                a[1].(int), 
            )
        },
    )
    dsl.funcs.register("blur-motion", "Applies a motion blur to an image along a specified angle.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to blur",
            },
            { 
                name: "length",
                typ:  "int", 
                min:  1, 
                max:  100, 
                def:  5, 
                desc: "The length of the motion blur (in pixels)",
            },
            { 
                name: "angle",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                desc: "The angle of the motion blur (in degrees)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blurred image",
            },
        },
        func(a ...any) (any, error) {
            return blurMotion(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(float64), 
            )
        },
    )
    dsl.funcs.register("blur-zoom", "Applies a zoom blur effect to an image.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to blur",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.25, 
                desc: "The strength of the blur effect (higher means more blur)",
            },
            { 
                name: "centerX",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "X coordinate of the blur center (default: image center)",
            },
            { 
                name: "centerY",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "Y coordinate of the blur center (default: image center)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The blurred image",
            },
        },
        func(a ...any) (any, error) {
            return blurZoom(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("invert", "Inverts an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to invert",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The inverted image",
            },
        },
        func(a ...any) (any, error) {
            return colorInvert(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("grayscale", "Grayscales an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to grayscale",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The grayscaled image",
            },
        },
        func(a ...any) (any, error) {
            return colorGrayscale(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("sepia", "Changes the tone of an image to sepia",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to change to sepia tone",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The sepia-toned image",
            },
        },
        func(a ...any) (any, error) {
            return colorSepia(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("brightness", "Changes the brightness of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to change brightness of",
            },
            { 
                name: "factor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  0, 
                desc: "The change factor",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with brightness changed",
            },
        },
        func(a ...any) (any, error) {
            return colorBrightness(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("fill", "Fills the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to fill",
            },
            { 
                name: "col",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The fill color",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The filled image",
            },
        },
        func(a ...any) (any, error) {
            return colorFill(
                a[0].(*image.NRGBA64),
                a[1].(color.RGBA64), 
            )
        },
    )
    dsl.funcs.register("colorize", "Colorizes the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to colorize",
            },
            { 
                name: "col",
                typ:  "color.RGBA64", 
                def:  "-", 
                desc: "The color that determines the hue to use for colorization",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The colorized image",
            },
        },
        func(a ...any) (any, error) {
            return colorColorize(
                a[0].(*image.NRGBA64),
                a[1].(color.RGBA64), 
            )
        },
    )
    dsl.funcs.register("contrast", "Adjusts the contrast of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust contrast of",
            },
            { 
                name: "factor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "The contrast factor (0 = gray, 1 = unchanged, 2 = maximum)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The contrast-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorContrast(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("saturation", "Adjusts the color saturation of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust saturation of",
            },
            { 
                name: "factor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "The saturation factor (0 = grayscale, 1 = unchanged, 2 = super saturated)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The saturation-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorSaturation(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("opacity", "Adjusts the overall opacity/transparency of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust opacity of",
            },
            { 
                name: "amount",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The opacity amount (0 = fully transparent, 1 = unchanged)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The opacity-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorOpacity(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("chromatic-aberration", "Creates a chromatic aberration effect by offsetting color channels",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to apply the effect to",
            },
            { 
                name: "amount",
                typ:  "float64", 
                min:  0, 
                max:  20, 
                def:  5, 
                desc: "The amount of color channel separation",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with chromatic aberration",
            },
        },
        func(a ...any) (any, error) {
            return colorChromaticAberration(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("hue-rotate", "Rotates the hue of image colors",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to rotate hue of",
            },
            { 
                name: "angle",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The angle in degrees (0-360)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The hue-rotated image",
            },
        },
        func(a ...any) (any, error) {
            return colorHueRotate(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("color-balance", "Adjusts the balance of Red, Green, and Blue channels",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust color balance of",
            },
            { 
                name: "rFactor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "Red channel adjustment factor",
            },
            { 
                name: "gFactor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "Green channel adjustment factor",
            },
            { 
                name: "bFactor",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "Blue channel adjustment factor",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The color-balanced image",
            },
        },
        func(a ...any) (any, error) {
            return colorBalance(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("posterize", "Reduces the number of color levels in the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to posterize",
            },
            { 
                name: "levels",
                typ:  "int", 
                min:  2, 
                max:  16, 
                def:  4, 
                desc: "Number of color levels per channel (2-16)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The posterized image",
            },
        },
        func(a ...any) (any, error) {
            return colorPosterize(
                a[0].(*image.NRGBA64),
                a[1].(int), 
            )
        },
    )
    dsl.funcs.register("threshold", "Converts image to black and white based on a brightness threshold",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to apply thresholding to",
            },
            { 
                name: "level",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "The brightness threshold",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The thresholded (black and white) image",
            },
        },
        func(a ...any) (any, error) {
            return colorThreshold(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("edge-detect", "Detects edges in the image using the Sobel operator",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to detect edges in",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "An image highlighting the edges",
            },
        },
        func(a ...any) (any, error) {
            return colorEdgeDetect(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("vignette", "Adds a vignette effect (darkens/lightens edges)",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to apply vignette to",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "Darkness/Lightness intensity (0 to 1)",
            },
            { 
                name: "falloff",
                typ:  "float64", 
                min:  0.1, 
                max:  2, 
                def:  0.8, 
                desc: "How quickly the effect fades (0.1 to 2.0)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with vignette effect",
            },
        },
        func(a ...any) (any, error) {
            return colorVignette(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    dsl.funcs.register("vibrance", "Adjusts the saturation of an image, protecting already saturated colors and skin tones.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust vibrance of",
            },
            { 
                name: "factor",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "The vibrance adjustment factor (-1 = less vibrant, 0 = unchanged, 1 = more vibrant)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The vibrance-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorVibrance(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("exposure", "Adjusts the overall lightness or darkness of the image, simulating photographic exposure.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to adjust exposure of",
            },
            { 
                name: "level",
                typ:  "float64", 
                min:  -2, 
                max:  2, 
                def:  0, 
                desc: "The exposure level adjustment (-2 = much darker, 0 = unchanged, 2 = much brighter)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The exposure-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorExposure(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("select-hue", "Selects a specific hue from the image and makes everything else transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "hue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The target hue to keep (in degrees)",
            },
            { 
                name: "toleranceLeft",
                typ:  "float64", 
                min:  0, 
                max:  180, 
                def:  30, 
                unit: "\"째\"", 
                desc: "How much to include to the left (lower hue, in degrees)",
            },
            { 
                name: "toleranceRight",
                typ:  "float64", 
                min:  0, 
                max:  180, 
                def:  30, 
                unit: "\"째\"", 
                desc: "How much to include to the right (higher hue, in degrees)",
            },
            { 
                name: "softness",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.5, 
                desc: "How soft the transition should be (0 = hard cut, 1 = very soft)",
            },
            { 
                name: "minSaturation",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.15, 
                desc: "The minimum saturation required to keep a pixel (smooth fade below)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with only the selected hue visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorSelectHue(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    dsl.funcs.register("select-hsl", "Selects pixels based on their hue, saturation, and luminance, making pixels outside the specified ranges transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "minHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  30, 
                unit: "\"째\"", 
                desc: "The minimum hue for full opacity (fade from 0% to 100% between lowerHue and this)",
            },
            { 
                name: "maxHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  330, 
                unit: "\"째\"", 
                desc: "The maximum hue for full opacity (fade from 100% to 0% between this and upperHue)",
            },
            { 
                name: "upperHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  360, 
                unit: "\"째\"", 
                desc: "The upper hue threshold (above this becomes transparent)",
            },
            { 
                name: "lowerSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower saturation threshold (below this becomes transparent)",
            },
            { 
                name: "minSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum saturation for full opacity (fade from 0% to 100% between lowerSat and this)",
            },
            { 
                name: "maxSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum saturation for full opacity (fade from 100% to 0% between this and upperSat)",
            },
            { 
                name: "upperSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper saturation threshold (above this becomes transparent)",
            },
            { 
                name: "lowerLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower luminance threshold (below this becomes transparent)",
            },
            { 
                name: "minLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum luminance for full opacity (fade from 0% to 100% between lowerLum and this)",
            },
            { 
                name: "maxLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum luminance for full opacity (fade from 100% to 0% between this and upperLum)",
            },
            { 
                name: "upperLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper luminance threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with only pixels in all specified ranges visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorSelectHSL(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64), 
            )
        },
    )
    dsl.funcs.register("remove-hsl", "Removes pixels based on their hue, saturation, and luminance, making pixels inside the specified ranges transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "minHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  30, 
                unit: "\"째\"", 
                desc: "The minimum hue for full opacity (fade from 0% to 100% between lowerHue and this)",
            },
            { 
                name: "maxHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  330, 
                unit: "\"째\"", 
                desc: "The maximum hue for full opacity (fade from 100% to 0% between this and upperHue)",
            },
            { 
                name: "upperHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  360, 
                unit: "\"째\"", 
                desc: "The upper hue threshold (above this becomes transparent)",
            },
            { 
                name: "lowerSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower saturation threshold (below this becomes transparent)",
            },
            { 
                name: "minSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum saturation for full opacity (fade from 0% to 100% between lowerSat and this)",
            },
            { 
                name: "maxSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum saturation for full opacity (fade from 100% to 0% between this and upperSat)",
            },
            { 
                name: "upperSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper saturation threshold (above this becomes transparent)",
            },
            { 
                name: "lowerLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower luminance threshold (below this becomes transparent)",
            },
            { 
                name: "minLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum luminance for full opacity (fade from 0% to 100% between lowerLum and this)",
            },
            { 
                name: "maxLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum luminance for full opacity (fade from 100% to 0% between this and upperLum)",
            },
            { 
                name: "upperLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper luminance threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with only pixels in all specified ranges visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorRemoveHSL(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64), 
            )
        },
    )
    dsl.funcs.register("invert-hsl", "Inverts pixels based on their hue, saturation, and luminance, inverting pixels inside the specified ranges",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "minHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  30, 
                unit: "\"째\"", 
                desc: "The minimum hue for full opacity (fade from 0% to 100% between lowerHue and this)",
            },
            { 
                name: "maxHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  330, 
                unit: "\"째\"", 
                desc: "The maximum hue for full opacity (fade from 100% to 0% between this and upperHue)",
            },
            { 
                name: "upperHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  360, 
                unit: "\"째\"", 
                desc: "The upper hue threshold (above this becomes transparent)",
            },
            { 
                name: "lowerSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower saturation threshold (below this becomes transparent)",
            },
            { 
                name: "minSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum saturation for full opacity (fade from 0% to 100% between lowerSat and this)",
            },
            { 
                name: "maxSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum saturation for full opacity (fade from 100% to 0% between this and upperSat)",
            },
            { 
                name: "upperSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper saturation threshold (above this becomes transparent)",
            },
            { 
                name: "lowerLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower luminance threshold (below this becomes transparent)",
            },
            { 
                name: "minLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum luminance for full opacity (fade from 0% to 100% between lowerLum and this)",
            },
            { 
                name: "maxLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum luminance for full opacity (fade from 100% to 0% between this and upperLum)",
            },
            { 
                name: "upperLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper luminance threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with only pixels in all specified ranges visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorInvertHSL(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64), 
            )
        },
    )
    dsl.funcs.register("rotate-hsl", "Rotates the hue of pixels based on their hue, saturation, and luminance",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "rotate",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "lowerHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  0, 
                unit: "\"째\"", 
                desc: "The lower hue threshold (below this becomes transparent)",
            },
            { 
                name: "minHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  30, 
                unit: "\"째\"", 
                desc: "The minimum hue for full opacity (fade from 0% to 100% between lowerHue and this)",
            },
            { 
                name: "maxHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  330, 
                unit: "\"째\"", 
                desc: "The maximum hue for full opacity (fade from 100% to 0% between this and upperHue)",
            },
            { 
                name: "upperHue",
                typ:  "float64", 
                min:  0, 
                max:  360, 
                def:  360, 
                unit: "\"째\"", 
                desc: "The upper hue threshold (above this becomes transparent)",
            },
            { 
                name: "lowerSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower saturation threshold (below this becomes transparent)",
            },
            { 
                name: "minSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum saturation for full opacity (fade from 0% to 100% between lowerSat and this)",
            },
            { 
                name: "maxSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum saturation for full opacity (fade from 100% to 0% between this and upperSat)",
            },
            { 
                name: "upperSat",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper saturation threshold (above this becomes transparent)",
            },
            { 
                name: "lowerLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower luminance threshold (below this becomes transparent)",
            },
            { 
                name: "minLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum luminance for full opacity (fade from 0% to 100% between lowerLum and this)",
            },
            { 
                name: "maxLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum luminance for full opacity (fade from 100% to 0% between this and upperLum)",
            },
            { 
                name: "upperLum",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper luminance threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with only pixels in all specified ranges visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorRotateHSL(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64),
                a[13].(float64), 
            )
        },
    )
    dsl.funcs.register("auto-levels", "Automatically adjusts the contrast and brightness of an image by stretching the histogram to use the full range of values, ignoring outliers using percentiles",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to auto-level",
            },
            { 
                name: "lowPercentile",
                typ:  "float64", 
                def:  0.05, 
                unit: "%", 
                desc: "The lower percentile to ignore (e.g., 0.5)",
            },
            { 
                name: "highPercentile",
                typ:  "float64", 
                def:  0.995, 
                unit: "%", 
                desc: "The upper percentile to ignore (e.g., 99.5)",
            },
            { 
                name: "adjustAlpha",
                typ:  "bool", 
                def:  false, 
                desc: "Whether to adjust alpha channel (false = preserve original alpha)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The auto-leveled image",
            },
        },
        func(a ...any) (any, error) {
            return colorAutoLevels(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(bool), 
            )
        },
    )
    dsl.funcs.register("auto-white-balance", "Automatically adjusts the white balance of an image by finding bright areas and making them neutral",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to auto-white-balance",
            },
            { 
                name: "threshold",
                typ:  "float64", 
                def:  0.95, 
                unit: "%", 
                desc: "The brightness threshold to consider as white (0-1)",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "How strongly to apply the white balance (0 = no change, 1 = full correction)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The white-balanced image",
            },
        },
        func(a ...any) (any, error) {
            return colorAutoWhiteBalance(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    dsl.funcs.register("auto-contrast", "Automatically adjusts the contrast of an image by stretching the histogram to use the full range of values",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to auto-contrast",
            },
            { 
                name: "threshold",
                typ:  "float64", 
                def:  0.01, 
                unit: "%", 
                desc: "The percentage of pixels to ignore at both ends of the histogram (0-0.5)",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "How strongly to apply the contrast adjustment (0 = no change, 1 = full correction)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The contrast-adjusted image",
            },
        },
        func(a ...any) (any, error) {
            return colorAutoContrast(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    dsl.funcs.register("auto-tone", "Automatically enhances the image by applying auto-levels, auto-white-balance, and auto-contrast in sequence",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to auto-tone",
            },
            { 
                name: "levelsLow",
                typ:  "float64", 
                def:  0.005, 
                unit: "%", 
                desc: "Lower percentile for auto-levels (e.g., 0.5)",
            },
            { 
                name: "levelsHigh",
                typ:  "float64", 
                def:  0.9995, 
                unit: "%", 
                desc: "Upper percentile for auto-levels (e.g., 99.5)",
            },
            { 
                name: "whiteThresh",
                typ:  "float64", 
                def:  0.99, 
                unit: "%", 
                desc: "Brightness threshold for auto-white-balance (0-1)",
            },
            { 
                name: "whiteStrength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "Strength for auto-white-balance (0-1)",
            },
            { 
                name: "contrastThresh",
                typ:  "float64", 
                def:  0.01, 
                unit: "%", 
                desc: "Percentile for auto-contrast (0-0.5)",
            },
            { 
                name: "contrastStrength",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "Strength for auto-contrast (0-1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The auto-toned image",
            },
        },
        func(a ...any) (any, error) {
            return colorAutoTone(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64), 
            )
        },
    )
    dsl.funcs.register("select-brightness", "Selects pixels based on their brightness, making pixels outside the specified range transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower brightness threshold (below this becomes transparent)",
            },
            { 
                name: "minBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum brightness for full opacity (fade from 0% to 100% between lowerBright and this)",
            },
            { 
                name: "maxBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum brightness for full opacity (fade from 100% to 0% between this and upperBright)",
            },
            { 
                name: "upperBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper brightness threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with only pixels in the specified brightness range visible (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorSelectBrightness(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    dsl.funcs.register("remove-brightness", "Removes pixels based on their brightness, making pixels inside the specified range transparent",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to process (16-bit)",
            },
            { 
                name: "lowerBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.1, 
                desc: "The lower brightness threshold (below this becomes transparent)",
            },
            { 
                name: "minBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.2, 
                desc: "The minimum brightness for full opacity (fade from 0% to 100% between lowerBright and this)",
            },
            { 
                name: "maxBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.8, 
                desc: "The maximum brightness for full opacity (fade from 100% to 0% between this and upperBright)",
            },
            { 
                name: "upperBright",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.9, 
                desc: "The upper brightness threshold (above this becomes transparent)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The image with pixels in the specified brightness range removed (16-bit)",
            },
        },
        func(a ...any) (any, error) {
            return colorRemoveBrightness(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    dsl.funcs.register("rectangular-to-polar", "Converts a rectangular coordinate image to polar coordinates",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to transform",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The transformed image",
            },
        },
        func(a ...any) (any, error) {
            return distortRectangularToPolar(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("polar-to-rectangular", "Converts a polar coordinate image to rectangular coordinates",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to transform",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The transformed image",
            },
        },
        func(a ...any) (any, error) {
            return distortPolarToRectangular(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("pixelate", "Creates a pixelation effect by averaging colors in blocks",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to pixelate",
            },
            { 
                name: "size",
                typ:  "int", 
                min:  1, 
                max:  50, 
                def:  8, 
                desc: "The size of the pixel blocks",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The pixelated image",
            },
        },
        func(a ...any) (any, error) {
            return distortPixelate(
                a[0].(*image.NRGBA64),
                a[1].(int), 
            )
        },
    )
    dsl.funcs.register("displace", "Displaces pixels based on the brightness of a displacement map",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to displace",
            },
            { 
                name: "dMap",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The displacement map image",
            },
            { 
                name: "amount",
                typ:  "float64", 
                min:  0, 
                max:  50, 
                def:  10, 
                desc: "The amount of displacement",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The displaced image",
            },
        },
        func(a ...any) (any, error) {
            return distortDisplace(
                a[0].(*image.NRGBA64),
                a[1].(*image.NRGBA64),
                a[2].(float64), 
            )
        },
    )
    dsl.funcs.register("defisheye", "Corrects fisheye lens distortion in an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to correct",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "The strength of the correction",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The corrected image",
            },
        },
        func(a ...any) (any, error) {
            return distortDefisheye(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("fisheye", "Applies a fisheye lens distortion effect to the image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to distort",
            },
            { 
                name: "strength",
                typ:  "float64", 
                min:  0, 
                max:  2, 
                def:  1, 
                desc: "The strength of the fisheye effect",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The distorted image",
            },
        },
        func(a ...any) (any, error) {
            return distortFisheye(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("enhance", "Enhances colors and sharpness of an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to enhance",
            },
            { 
                name: "brightness",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "The brightness adjustment of the image",
            },
            { 
                name: "contrast",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "The contrast adjustment of the image",
            },
            { 
                name: "sharpening",
                typ:  "float64", 
                min:  0, 
                max:  5, 
                def:  1, 
                desc: "The sharpening intensity in pixels (higher values detect larger edges)",
            },
            { 
                name: "rMin",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.75, 
                desc: "The minimum intensity of the red channel",
            },
            { 
                name: "rMax",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The maximum intensity of the red channel",
            },
            { 
                name: "gMin",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.75, 
                desc: "The minimum intensity of the green channel",
            },
            { 
                name: "gMax",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The maximum intensity of the green channel",
            },
            { 
                name: "bMin",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.75, 
                desc: "The minimum intensity of the blue channel",
            },
            { 
                name: "bMax",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The maximum intensity of the blue channel",
            },
            { 
                name: "rWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.299, 
                desc: "The weight of the red channel (used for sharpening)",
            },
            { 
                name: "gWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.587, 
                desc: "The weight of the green channel (used for sharpening)",
            },
            { 
                name: "bWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.114, 
                desc: "The weight of the blue channel (used for sharpening)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The enhanceed image",
            },
        },
        func(a ...any) (any, error) {
            return enhance(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64),
                a[6].(float64),
                a[7].(float64),
                a[8].(float64),
                a[9].(float64),
                a[10].(float64),
                a[11].(float64),
                a[12].(float64), 
            )
        },
    )
    dsl.funcs.register("sharpen", "Sharpens an image using a highpass combined with vivid light blending",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to sharpen",
            },
            { 
                name: "intensity",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The intensity of the sharpening effect",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0.1, 
                max:  2, 
                def:  1, 
                desc: "The radius of the filter in pixels (higher values detect larger edges)",
            },
            { 
                name: "rWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.299, 
                desc: "The weight of the red channel",
            },
            { 
                name: "gWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.587, 
                desc: "The weight of the green channel",
            },
            { 
                name: "bWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.114, 
                desc: "The weight of the blue channel",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The sharpened image",
            },
        },
        func(a ...any) (any, error) {
            return sharpen(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    dsl.funcs.register("highpass", "Creates a high pass filter effect, resulting in a gray image with embossed edges",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to apply the high-pass filter to",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0.1, 
                max:  2, 
                def:  1, 
                desc: "The radius of the filter in pixels (higher values detect larger edges)",
            },
            { 
                name: "rWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.299, 
                desc: "The weight of the red channel",
            },
            { 
                name: "gWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.587, 
                desc: "The weight of the green channel",
            },
            { 
                name: "bWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.114, 
                desc: "The weight of the blue channel",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The filtered image",
            },
        },
        func(a ...any) (any, error) {
            return sharpenHighpass(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    dsl.funcs.register("clarity", "Enhances local contrast while preserving overall image structure",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to enhance",
            },
            { 
                name: "intensity",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "The intensity of the clarity effect",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0.1, 
                max:  2, 
                def:  1, 
                desc: "The radius of the filter in pixels (higher values affect larger areas)",
            },
            { 
                name: "rWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.299, 
                desc: "The weight of the red channel",
            },
            { 
                name: "gWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.587, 
                desc: "The weight of the green channel",
            },
            { 
                name: "bWeight",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  0.114, 
                desc: "The weight of the blue channel",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The enhanced image",
            },
        },
        func(a ...any) (any, error) {
            return clarity(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    dsl.funcs.register("translate", "Translates (moves) an image by a specified amount",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to translate",
            },
            { 
                name: "dx",
                typ:  "float64", 
                def:  0, 
                desc: "The horizontal translation amount in % (positive = right)",
            },
            { 
                name: "dy",
                typ:  "float64", 
                def:  0, 
                desc: "The vertical translation amount in % (positive = down)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The translated image",
            },
        },
        func(a ...any) (any, error) {
            return translate(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    dsl.funcs.register("rotate", "Rotates an image around its center by a specified angle",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to rotate",
            },
            { 
                name: "angle",
                typ:  "float64", 
                min:  -360, 
                max:  360, 
                def:  0, 
                desc: "The rotation angle in degrees (positive = clockwise)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The rotated image",
            },
        },
        func(a ...any) (any, error) {
            return rotate(
                a[0].(*image.NRGBA64),
                a[1].(float64), 
            )
        },
    )
    dsl.funcs.register("scale", "Scales an image by specified factors",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to scale",
            },
            { 
                name: "sx",
                typ:  "float64", 
                def:  0, 
                desc: "The horizontal scale factor",
            },
            { 
                name: "sy",
                typ:  "float64", 
                def:  0, 
                desc: "The vertical scale factor",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The scaled image",
            },
        },
        func(a ...any) (any, error) {
            return scale(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64), 
            )
        },
    )
    dsl.funcs.register("transform", "Applies translation, rotation, and scaling to an image in one operation",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to transform",
            },
            { 
                name: "dx",
                typ:  "float64", 
                def:  0, 
                desc: "The horizontal translation in pixels",
            },
            { 
                name: "dy",
                typ:  "float64", 
                def:  0, 
                desc: "The vertical translation in pixels",
            },
            { 
                name: "angle",
                typ:  "float64", 
                def:  0, 
                desc: "The rotation angle in degrees (clockwise)",
            },
            { 
                name: "sx",
                typ:  "float64", 
                def:  0, 
                desc: "The horizontal scale factor",
            },
            { 
                name: "sy",
                typ:  "float64", 
                def:  0, 
                desc: "The vertical scale factor",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The transformed image",
            },
        },
        func(a ...any) (any, error) {
            return transform(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64),
                a[5].(float64), 
            )
        },
    )
    dsl.funcs.register("flip-v", "Flips an image vertically (top to bottom)",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to flip vertically",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The vertically flipped image",
            },
        },
        func(a ...any) (any, error) {
            return flipVertical(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("flip-h", "Flips an image horizontally (left to right)",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to flip horizontally",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The horizontally flipped image",
            },
        },
        func(a ...any) (any, error) {
            return flipHorizontal(
                a[0].(*image.NRGBA64), 
            )
        },
    )
    dsl.funcs.register("crop", "Crops an image by specified percentages from each side",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "left",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to crop from the left side (0-1)",
            },
            { 
                name: "right",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to crop from the right side (0-1)",
            },
            { 
                name: "top",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to crop from the top side (0-1)",
            },
            { 
                name: "bottom",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to crop from the bottom side (0-1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The cropped image",
            },
        },
        func(a ...any) (any, error) {
            return crop(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    dsl.funcs.register("crop-px", "Crops an image by specified amounts of pixels from each side",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "left",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to crop from the left side",
            },
            { 
                name: "right",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to crop from the right side",
            },
            { 
                name: "top",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to crop from the top side",
            },
            { 
                name: "bottom",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to crop from the bottom side",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The cropped image",
            },
        },
        func(a ...any) (any, error) {
            return cropPx(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(int),
                a[3].(int),
                a[4].(int), 
            )
        },
    )
    dsl.funcs.register("crop-circle", "Crops an image using a circular mask. The circle is centered at (centerX+offsetX, centerY+offsetY) and the radius is a percentage (0-1) of half the minimum image dimension.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Radius as a percentage of half the min(width, height)",
            },
            { 
                name: "offsetX",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Horizontal offset from image center (percentage of width, -1..1)",
            },
            { 
                name: "offsetY",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Vertical offset from image center (percentage of height, -1..1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The circularly cropped image (pixels outside the circle are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropCircle(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("crop-circle-px", "Crops an image using a circular mask. The circle is centered at (centerX+offsetX, centerY+offsetY) and the radius is a percentage (0-1) of half the minimum image dimension.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "radius",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Radius as a percentage of half the min(width, height)",
            },
            { 
                name: "offsetX",
                typ:  "int", 
                def:  0, 
                desc: "Horizontal offset from image center (pixels)",
            },
            { 
                name: "offsetY",
                typ:  "int", 
                def:  0, 
                desc: "Vertical offset from image center (pixels)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The circularly cropped image (pixels outside the circle are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropCirclePx(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(int),
                a[3].(int), 
            )
        },
    )
    dsl.funcs.register("crop-square", "Crops an image using a square mask. The square is centered at (centerX+offsetX, centerY+offsetY) and the size is a percentage (0-1) of the minimum image dimension.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "size",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Size as a percentage of the min(width, height)",
            },
            { 
                name: "offsetX",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Horizontal offset from image center (percentage of width, -1..1)",
            },
            { 
                name: "offsetY",
                typ:  "float64", 
                min:  -1, 
                max:  1, 
                def:  0, 
                desc: "Vertical offset from image center (percentage of height, -1..1)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The square-cropped image (pixels outside the square are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropSquare(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64), 
            )
        },
    )
    dsl.funcs.register("crop-square-px", "Crops an image using a square mask. The square is centered at (centerX+offsetX, centerY+offsetY) and the size is a percentage (0-1) of the minimum image dimension.",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to crop",
            },
            { 
                name: "size",
                typ:  "float64", 
                min:  0, 
                max:  1, 
                def:  1, 
                desc: "Size as a percentage of the min(width, height)",
            },
            { 
                name: "offsetX",
                typ:  "int", 
                def:  0, 
                desc: "Horizontal offset from image center (pixels)",
            },
            { 
                name: "offsetY",
                typ:  "int", 
                def:  0, 
                desc: "Vertical offset from image center (pixels)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The square-cropped image (pixels outside the square are transparent)",
            },
        },
        func(a ...any) (any, error) {
            return cropSquarePx(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(int),
                a[3].(int), 
            )
        },
    )
    dsl.funcs.register("expand", "Expands an image by adding transparent borders with specified percentage widths",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to expand",
            },
            { 
                name: "left",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to add to the left side (relative to original width)",
            },
            { 
                name: "right",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to add to the right side (relative to original width)",
            },
            { 
                name: "top",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to add to the top side (relative to original height)",
            },
            { 
                name: "bottom",
                typ:  "float64", 
                def:  0, 
                desc: "The percentage to add to the bottom side (relative to original height)",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The expanded image",
            },
        },
        func(a ...any) (any, error) {
            return expand(
                a[0].(*image.NRGBA64),
                a[1].(float64),
                a[2].(float64),
                a[3].(float64),
                a[4].(float64), 
            )
        },
    )
    dsl.funcs.register("expand-px", "Expands an image by adding transparent borders with specified pixel widths",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to expand",
            },
            { 
                name: "left",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to add to the left side",
            },
            { 
                name: "right",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to add to the right side",
            },
            { 
                name: "top",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to add to the top side",
            },
            { 
                name: "bottom",
                typ:  "int", 
                def:  0, 
                desc: "The number of pixels to add to the bottom side",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The expanded image",
            },
        },
        func(a ...any) (any, error) {
            return expandPx(
                a[0].(*image.NRGBA64),
                a[1].(int),
                a[2].(int),
                a[3].(int),
                a[4].(int), 
            )
        },
    )
    dsl.funcs.register("resize-max-mp", "Resize an image to stay within a maximum amount of megapixels",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to resize",
            },
            { 
                name: "mpMax",
                typ:  "int", 
                def:  0, 
                desc: "The maximum amount of megapixels",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The resized image",
            },
        },
        func(a ...any) (any, error) {
            return resizeToMaxMP(
                a[0].(*image.NRGBA64),
                a[1].(int), 
            )
        },
    )
    dsl.funcs.register("load", "Loads an image",
        []dslParamMeta{ 
            { 
                name: "path",
                typ:  "string", 
                def:  "-", 
                desc: "- - Path to the image",
            },
        },
        []dslParamMeta{     
            { 
                name: "result",
                typ:  "any", 
                def:  "-", 
                desc: "The loaded image",
            },
        },
        func(a ...any) (any, error) {
            return load(
                a[0].(string), 
            )
        },
    )
    dsl.funcs.register("save", "Saves an image",
        []dslParamMeta{ 
            { 
                name: "img",
                typ:  "*image.NRGBA64", 
                def:  "-", 
                desc: "The image to save",
            },
            { 
                name: "path",
                typ:  "string", 
                def:  "-", 
                desc: "- - Path where to save",
            },
        },
        []dslParamMeta{ 
        },
        func(a ...any) (any, error) {
            return save(
                a[0].(*image.NRGBA64),
                a[1].(string), 
            )
        },
    )
    dsl.funcs.storeState() // Store the state of functions, so we can reset the language without losing them
} 